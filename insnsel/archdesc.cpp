#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <cctype>
#include <iterator>

#include "parser.hpp"
#include "archdesc.hpp"

class declDestructor {
public:
  declDestructor(const std::string &nm)
    : name(nm) {
  }

  const std::string &name;
};

std::ostream &operator<<(std::ostream &out, const declDestructor &d) {
  out << d.name << "::~" << d.name << "()";
  return out;
}

class declMember {
public:
  declMember(const std::string &ty, const std::string &clsNm, const std::string &fnName)
    : m_type(ty), m_clsNm(clsNm), m_fnName(fnName), m_isConst(false) {
  }

  declMember &_const () { m_isConst = true; return *this; }
  declMember &arg(const std::string &arg) {
    if ( m_args.tellp() > 0 ) m_args << ", ";
    m_args << arg;
    return *this;
  }

  const std::string &m_type;
  const std::string &m_clsNm;
  const std::string &m_fnName;

  std::stringstream m_args;
  bool m_isConst;
};

std::ostream &operator<<(std::ostream &out, const declMember &d) {
  out << d.m_type << " " << d.m_clsNm << "::" << d.m_fnName << "(" << d.m_args.str() << ") ";
  if ( d.m_isConst )
    out << "const ";
  return out;
}

class StandardImpl : public IndentedHeaderBase {
public:
  StandardImpl(std::ostream &out)
    : m_out(out), m_namespaces(0) {
    m_out << "/* This file is auto-generated by archdescc. Do not modify */" << std::endl;
  }

  ~StandardImpl() {
    popAllNamespaces();
  }

  void pushNamespace(const std::string &n) {
    indent() << "namespace " << n << " {" << std::endl;
    m_namespaces++;
  }

  void popNamespace() {
    m_namespaces--;
    indent() << "}" << std::endl;
  }

  void popAllNamespaces() {
    while ( m_namespaces > 0 ) popNamespace();
  }

  virtual std::ostream &noindent() const { return m_out; }

  virtual std::ostream &indent(int extra = 0) const {
    int spaces = (m_namespaces + extra) * 2;
    std::fill_n(std::ostream_iterator<char>(m_out), spaces, ' ');
    return m_out;
  };

  virtual std::string var(const std::string &base) {
    auto it (m_vars.find(base));
    if ( it == m_vars.end() ) {
      m_vars.insert(std::make_pair(base, 1));
      return base + "0";
    } else {
      std::stringstream vn;
      vn << base << it->second;
      it->second++;
      return vn.str();
    }
  }

protected:
  std::ostream &m_out;
  int m_namespaces;
  std::map<std::string, int> m_vars;
};

class StandardHeader : public StandardImpl {
public:
  StandardHeader(std::ostream &out, ArchDescBuilder &b, const std::string &what)
    : StandardImpl(out) {
    m_out << "#ifndef __nnc_compile_" << b.cArchName() << "_" << what << "_HPP__" << std::endl;
    m_out << "#define __nnc_compile_" << b.cArchName() << "_" << what << "_HPP__" << std::endl;
    m_out << std::endl;
    b.includeCHeaders(m_out);
    m_out << std::endl;
  }

  ~StandardHeader() {
    popAllNamespaces();
    m_out << "#endif" << std::endl;
  }
};

class IndentedHeader : public IndentedHeaderBase {
public:
  IndentedHeader(IndentedHeaderBase &b, int n = 1)
    : m_base(b), m_n(n) {
  }

  virtual std::ostream &indent(int extra = 0) const {
    return m_base.indent(extra + m_n);
  }
  virtual std::ostream &noindent() const { return m_base.noindent(); }

  virtual std::string var(const std::string &base) {
    return m_base.var(base);
  }

private:
  IndentedHeaderBase &m_base;
  int m_n;
};

class MnemonicsCollector : public MnemonicInterestDeclarer, public InsnPatternVisitor {
private:
  std::set<std::string> m_mnemonics;
  int m_patternCount, m_branchCount;

  struct branch {
  public:
    branch(): altCount(0), subCount(0), maxSubCount(0) { }

    void pushAlt() {
      if ( subCount > maxSubCount ) maxSubCount = subCount;
      subCount = 0;
    }

    int curSubCount() const { return (maxSubCount > subCount ? maxSubCount : subCount); }

    int altCount, subCount, maxSubCount;
  };
  std::vector<branch> m_branches;

public:
  typedef decltype(m_mnemonics)::iterator iterator;
  MnemonicsCollector() : m_patternCount(0), m_branchCount(0) {
  }
  virtual ~MnemonicsCollector() {
  }

  iterator begin() { return m_mnemonics.begin(); }
  iterator end() { return m_mnemonics.end(); }

  virtual void declareInterest(const std::string &mn) {
    m_mnemonics.insert(mn);
  }

  virtual void visit(const InsnPattern &p) {
    p.declMnemonicInterest(*this);
    m_patternCount++;
  }

  virtual void newBranch() {
    if ( m_branches.empty() ) m_branchCount ++;
    else m_branches.back().subCount ++;

    m_branches.emplace_back();
  }

  virtual void newAlternative() {
    m_branches.back().altCount++;
    m_branches.back().pushAlt();
  }

  virtual void endBranch() {
    int sub(m_branches.back().curSubCount());
    m_branches.pop_back();

    if ( !m_branches.empty() )
      m_branches.back().subCount += sub;
    else
      m_branchCount += sub;
  }

  inline int branchCount() const { return m_branchCount; }
  inline bool hasBranches() const { return branchCount() > 0; }
  inline int patternCount() const { return m_patternCount; }
};

class VariableCollector : public InsnVariableVisitor {
public:
  VariableCollector(InsnRule &rule)
    : m_rule(rule) {
  }

  virtual void visit(const std::string &name, bool isType) {
    if ( !m_rule.has_var(name) ) {
      std::stringstream err;
      err << "Rule has no variable named " << name;
      throw NncGenerationError(m_rule.errorContext(), err);
    } else {
      auto &var(m_rule.var(name));
      if ( isType && var.type() != InsnVariable::RegTypeType )  {
        std::stringstream err;
        err << "Variable " << name << " used in type position, but it's not a type";
        throw NncGenerationError(m_rule.errorContext(), err);
      }

      m_vars[name] = &var;
    }
  }

  typedef std::map<std::string, InsnVariable *> variables_type;
  variables_type &all() { return m_vars; }
private:
  InsnRule &m_rule;
  variables_type m_vars;
};

class RuleMatcherGen : public InsnPatternVisitor {
public:
  RuleMatcherGen(InsnRule &rule, IndentedHeaderBase &hdr)
    : m_insnNum(0), m_rule(rule), m_header(hdr) {
  }
  virtual ~RuleMatcherGen() {}

  virtual void visit(const InsnPattern &p) {
    std::stringstream clsnm;
    InsnRule &rule(m_rule);
    IndentedHeaderBase &hdr(m_header);
    int insnnum(m_insnNum);

    clsnm << cName(rule.name()) << "_operand_" << insnnum << "_matcher";
    hdr.indent() << "class " << clsnm.str() << " : public virtual ::nnc::compile::RtlOperandVisitor {" << std::endl;
    hdr.indent() << "public:" << std::endl;
    hdr.indent(1) << clsnm.str() << "(::nnc::compile::RtlFunction &fn)" << std::endl;

    VariableCollector vars(rule);
    // Collect variables
    p.visitVars(vars);

    hdr.indent(1) << ": RtlOperandVisitor(fn)" << std::endl;
    for ( const auto &var : vars.all() ) {
      if ( var.second->type() != InsnVariable::ConstantType ) {
        hdr.indent(1) << ", var_" << cName(var.first) << "(nullptr)" << std::endl;
      }
    };

    hdr.indent(1) << "{ }" << std::endl << std::endl;

    hdr.indent(1) << "bool complete() const {" << std::endl;
    for ( const auto &var : vars.all() ) {
      switch ( var.second->type() ) {
      case InsnVariable::ConstantType:
        hdr.indent(2) << "if ( !var_" << cName(var.first) << ".data() )";
        break;

      case InsnVariable::RegTypeType:
      case InsnVariable::RegisterType:
        hdr.indent(2) << "if ( !var_" << cName(var.first) << " )";
        break;
      }

      hdr.noindent() << " return false;" << std::endl;
    }
    hdr.indent(2) << "return true;" << std::endl;
    hdr.indent(1) << "}" << std::endl << std::endl;

    hdr.indent(1) << "virtual void operand(const std::string &name, const ::nnc::compile::RtlBlockName &dest) { }" << std::endl << std::endl;

    hdr.indent(1) << "virtual void operand(const std::string &name, std::shared_ptr<::nnc::compile::RtlVariable> var, bool input, bool output) {" << std::endl;

    for ( const auto &arg : p.args() ) {
      if ( rule.var(arg.second.var()).type() == InsnVariable::RegisterType ) {
        hdr.indent(2) << "if ( name == \"" << arg.first << "\" ) {" << std::endl;
        hdr.indent(3) << "var_" << cName(arg.second.var()) << " = var;" << std::endl;
        if ( arg.second.tyVar() ) {
          hdr.indent(3) << "var_" << cName(*arg.second.tyVar()) << " = var->type();" << std::endl;
        }
        hdr.indent(2) << "}" << std::endl;
      }
    }

    hdr.indent(1) << "}" << std::endl << std::endl;

    hdr.indent(1) << "virtual void operand(const std::string &name, std::shared_ptr<::nnc::compile::RtlType> ty, const void *l, std::size_t lsz) {" << std::endl;
    for ( const auto &arg : p.args() ) {
      if ( rule.var(arg.second.var()).type() == InsnVariable::ConstantType ) {
        hdr.indent(2) << "if ( name == \"" << arg.first << "\" ) {" << std::endl;
        hdr.indent(3) << "var_" << cName(arg.second.var()) << " = std::span<std::uint8_t>((std::uint8_t *)l, lsz);" << std::endl;
        if ( arg.second.tyVar() ) {
          hdr.indent(3) << "var_" << cName(*arg.second.tyVar()) << " = ty;" << std::endl;
        }
        hdr.indent(2) << "}" << std::endl;
      }
    }
    hdr.indent(1) << "}" << std::endl;

    for ( const auto &var: vars.all() ) {
      IndentedHeader b(hdr, 1);
      declVar(var.first, var.second->type(), b);
    }

    hdr.indent() << "};" << std::endl << std::endl;

    m_insnNum++;
  }

private:
  int m_insnNum;

  InsnRule &m_rule;
  IndentedHeaderBase &m_header;
};

class MnemonicApplyGen : public InsnPatternVisitor {
private:
  struct branch {
    branch(int i) : baseIx(i), nextBaseIx(i), maxSubCount(0), subCount(0), altNum(0) { }

    void updateSubCount() {
      if ( subCount > maxSubCount ) maxSubCount = subCount;
      subCount = 0;
    }

    void nextAlt() {  altNum++; }
    void outputCondition(std::ostream &o) const {
      o << "(branches[" << baseIx << "] == 0 || branches[" << baseIx << "] == " << altNum << ")";
    }
    void updateRule(std::ostream &o, const std::string &what) const {
      o << what << "->branches[" << baseIx << "] = " << altNum << ";" << std::endl;
    }

    int baseIx, nextBaseIx, maxSubCount, subCount, altNum;
  };

public:
  MnemonicApplyGen(const std::string &mn, InsnRule &rule, const IndentedHeaderBase &b)
    : m_insnNum(0), m_branchNum(0), m_mnemonic(mn), m_rule(rule), m_header(b) {
  }
  virtual ~MnemonicApplyGen() {
  }

  std::ostream &curBranchCondition(std::ostream &o) const {
      for ( const auto &br: m_branches ) {
        o << " && ";
        br.outputCondition(o);
      }
      return o;
  }

  virtual void visit(const InsnPattern &p) {
    if ( p.mnemonic() == m_mnemonic ) {
      int insnnum(m_insnNum);
      const IndentedHeaderBase &h(m_header);
      InsnRule &rule(m_rule);

      h.indent(1) << "if ( !ops[" << insnnum << "]";
      curBranchCondition(h.noindent()) << ") {" << std::endl;
      h.indent(2) << cName(rule.name()) << "_operand_" << insnnum << "_matcher matcher(fn);" << std::endl;
      h.indent(2) << "op.operands(matcher);" << std::endl;

      VariableCollector vars(rule);
      p.visitVars(vars);

      h.indent(2) << "if ( matcher.complete() ) {" << std::endl;
      // Now check each argument
      h.indent(3) << "newRule = new " << cName(rule.name()) << "(*this);" << std::endl;

      // Update branches
      for (const auto &br: m_branches)
        br.updateRule(h.indent(3), "newRule");

      for ( const auto &var : vars.all() ) {
        std::stringstream v;
        v << "var_" << cName(var.first);

        switch ( var.second->type() ) {
        case InsnVariable::ConstantType:
          h.indent(3) << "if ( " << v.str() << ".data() && !std::equal(std::begin(" << v.str() << "), std::end(" << v.str() << "), std::begin(matcher." << v.str() << "), std::end(matcher." << v.str() << ")) ) goto skip_insn_" << insnnum << ";" << std::endl;
          h.indent(3) << "else if ( !" << v.str() << ".data() ) newRule->" << v.str() << " = matcher." << v.str() << ";" << std::endl;
          break;

        case InsnVariable::RegisterType:
          h.indent(3) << "if ( var_" << cName(var.first) << " && !(var_" << cName(var.first) << "->isSame(matcher.var_" << cName(var.first) << ")) ) goto skip_insn_" << insnnum << ";" << std::endl;
          h.indent(3) << "else if ( !var_" << cName(var.first) << ") newRule->var_" << cName(var.first) << " = matcher.var_" << cName(var.first) << ";" << std::endl << std::endl;
          break;

        default:
          h.indent(3) << "if ( var_" << cName(var.first) << " && var_" << cName(var.first) << "!= matcher.var_" << cName(var.first) << " ) goto skip_insn_" << insnnum << ";" << std::endl;
          h.indent(3) << "else if ( !var_" << cName(var.first) << ") newRule->var_" << cName(var.first) << " = matcher.var_" << cName(var.first) << ";" << std::endl << std::endl;
          break;
        };
      }

      h.indent(3) << "newRule->ops[" << insnnum << "] = &op;" << std::endl;
      h.indent(3) << "if ( newRule->complete() ) {" << std::endl;
      h.indent(4) << "if ( newRule->check() ) {" << std::endl;
      h.indent(5) << "std::unique_ptr<::nnc::compile::SelectedInsn> selInsnPtr(static_cast<::nnc::compile::SelectedInsn *>(newRule));" << std::endl;
      h.indent(5) << "sel.markInsnSchedulable(std::move(selInsnPtr));" << std::endl;
      h.indent(4) << "}" << std::endl;
      h.indent(3) << "}" << std::endl;
      h.indent(3) << "if ( newRule->canContinue() ) {" << std::endl;
      h.indent(4) << "std::unique_ptr<::nnc::compile::InsnSelRule> newRulePtr(static_cast<::nnc::compile::InsnSelRule *>(newRule));" << std::endl;
      h.indent(4) << "sel.addRule(std::move(newRulePtr));" << std::endl;
      h.indent(3) << "}" << std::endl;
      h.indent(3) << "newRule = nullptr;" << std::endl;
      h.indent(2) << "skip_insn_" << insnnum << ":" << std::endl;
      h.indent(3) << "delete newRule;" << std::endl;
      h.indent(2) << "}" << std::endl;
      h.indent(1) << "}" << std::endl;
    }

    ++m_insnNum;
  }

  virtual void newBranch() override {
    if ( m_branches.empty() ) {
      m_branches.emplace_back(m_branchNum);
      m_branchNum++;
    } else {
      m_branches.back().subCount ++;
      m_branches.emplace_back(m_branches.back().nextBaseIx + 1);
    }
  }

  virtual void newAlternative() override {
    m_branches.back().updateSubCount();
    m_branches.back().nextAlt();
  }

  virtual void endBranch() override {
    m_branches.back().updateSubCount();
    int sub(m_branches.back().maxSubCount);
    m_branches.pop_back();

    if ( m_branches.empty() ) m_branchNum += sub;
    else {
      m_branches.back().nextBaseIx += sub;
      m_branches.back().subCount += sub;
    }
  }

private:
  int m_insnNum, m_branchNum;
  const std::string &m_mnemonic;
  InsnRule &m_rule;
  const IndentedHeaderBase &m_header;

  std::vector<branch> m_branches;
};

class CompleteExpr {
public:
  enum ExprType { Disjunction, Conjunction };
  CompleteExpr(CompleteExpr *parent, ExprType ty)
    : m_parent(parent), m_final(parent->m_final), m_first(true), m_tautology(false), m_type(ty), m_startIx(-1), m_endIx(-1) {
  }
  CompleteExpr(std::ostream &out, ExprType ty)
    : m_parent(nullptr), m_final(out), m_first(true), m_tautology(false), m_type(ty), m_startIx(-1), m_endIx(-1) {
  }

  ~CompleteExpr() {
    flushRange();

    bool def(m_type == Conjunction);
    if ( m_tautology ) def = !def;

    if ( m_first ) {
      if ( m_parent ) m_parent->constant(def);
      else m_final << (def ? "true" : "false");
    } else {
      if ( m_parent && !m_parent->m_tautology ) {
        if ( !m_parent->m_first ) m_parent->m_out << m_parent->oper();
        m_parent->m_out << "(" << m_out.str() << ")";
        m_parent->m_first = false;
      } else m_final << "(" << m_out.str() << ")";
    }
  }

  void include(int ix) {
    if ( m_tautology ) return;

    if ( m_startIx < 0 ) { m_startIx = ix; m_endIx = ix + 1; }
    else if ( ix == m_endIx ) { m_endIx = ix + 1; }
    else flushRange();
  }

  void constant(bool d) {
    if ( (m_type == Disjunction && d) ||
         (m_type == Conjunction && !d ) ) {
      m_tautology = true;
      m_first = true;
      m_out.str("");
    }
  }

  inline ExprType type() const { return m_type; }
  inline CompleteExpr *parent() const { return m_parent; }

private:
  void flushRange() {
    if ( m_startIx >= 0 && m_endIx > m_startIx ) {
      if ( !m_first ) m_out << oper();
      if ( (m_endIx - m_startIx) == 1 ) {
        m_out << "ops[" << m_startIx << "]";
      } else {
        m_out << "std::all_of(ops + " << m_startIx
              << ", ops + " << m_endIx
              << ", std::identity())";
      }
      m_startIx = m_endIx = -1;
      m_first = false;
    }
  }

  const char *oper() const {
    switch (m_type) {
    case Disjunction: return " || ";
    default: case Conjunction: return " && ";
    }
  }

  CompleteExpr *m_parent;
  std::ostream &m_final;
  std::stringstream m_out;
  bool m_first, m_tautology;
  ExprType m_type;
  int m_startIx, m_endIx;
};

class CompleteGen : public InsnPatternVisitor {
public:
  CompleteGen(IndentedHeaderBase &b)
    : m_header(b), m_opNum(0), m_branches(nullptr) {
    m_header.indent() << "return ";
    pushConjunction();
  }

  virtual ~CompleteGen() {
  }

  void finish() {
    while ( m_branches ) {
      CompleteExpr *next(m_branches->parent());
      delete m_branches;
      m_branches = next;
    }
    m_header.noindent() << ";" << std::endl;
  }

  virtual void visit(const InsnPattern &p) {
    curConj().include(m_opNum);
    m_opNum++;
  }

  virtual void newBranch() {
    pushDisjunction();
  }

  virtual void newAlternative() {
    if ( m_branches && m_branches->type() == CompleteExpr::Conjunction ) {
      auto branch(m_branches);
      m_branches = m_branches->parent();
      delete branch;
      newAlternative();
    }
    pushConjunction();
  }

  virtual void endBranch() {
    popDisjunction();
  }

private:
  CompleteExpr &curConj() {
    pushConjunction();
    return *m_branches;
  }

  void pushConjunction() {
    if ( !m_branches ) {
      m_branches = new CompleteExpr(m_header.noindent(), CompleteExpr::Conjunction);
    } else {
      m_branches = new CompleteExpr(m_branches, CompleteExpr::Conjunction);
    }
  }

  void pushDisjunction() {
    if ( !m_branches ) {
      m_branches = new CompleteExpr(m_header.noindent(), CompleteExpr::Disjunction);
    } else {
      m_branches = new CompleteExpr(m_branches, CompleteExpr::Disjunction);
    }
  }

  void popDisjunction() {
    if ( !m_branches ) return;
    else if ( m_branches->type() == CompleteExpr::Conjunction ) {
      auto branch(m_branches);
      m_branches = m_branches->parent();
      delete branch;
      popDisjunction();
    } else {
      auto branch(m_branches);
      m_branches = m_branches->parent();
      delete branch;
    }
  }


  IndentedHeaderBase &m_header;
  int m_opNum;
  CompleteExpr *m_branches;
};

FilesystemGenerator::FilesystemGenerator(const std::filesystem::path &base)
  : m_base(base) {
}

FilesystemGenerator::~FilesystemGenerator() {
}

void FilesystemGenerator::generate(const std::filesystem::path &outPath,
                                   std::function<void(const std::filesystem::path &)> generator) {
  std::error_code ec;
  std::filesystem::path output(m_base / outPath);

  if ( std::filesystem::create_directories(output.parent_path(), ec) ) {
    std::cerr << "Creating output directory " << output.parent_path() << std::endl;
  }

  if ( ec ) {
    std::cerr << "Error creating " << output.parent_path() << ": " << ec << std::endl;
  }
  std::cerr << "Generating " << output << std::endl;
  generator(output);
}

DepsDumper::DepsDumper(const ArchDescBuilder &b,
                       const std::filesystem::path &relPath,
                       std::ostream &out)
  : m_builder(b), m_out(out), m_relative(relPath) {
}

DepsDumper::~DepsDumper() {
}

void DepsDumper::generate(const std::filesystem::path &outPath,
                          std::function<void(const std::filesystem::path &)> generator) {
  m_out << (m_relative / outPath).native() << ": ";
  std::transform(m_builder.lexers().begin(),
                 m_builder.lexers().end(), std::ostream_iterator<std::string>(m_out, " "),
                 [](const auto &lexer) {
                   return lexer.second->filename();
                 });
  m_out << std::endl;
}

ArchDescBuilder::ArchDescBuilder() {
}

void ArchDescBuilder::setArchitecture(const std::string &name) {
  if ( m_name ) {
    std::cerr << "TODO name given twice" << std::endl;
  }

  m_name = name;
}

void ArchDescBuilder::includeFile(const std::string &fromFile, const std::string &filename) {
  std::filesystem::path path(fromFile);
  path = path.parent_path();

  std::filesystem::path includedPath(filename);

  path /= includedPath;
  includeFile(path);
}

void ArchDescBuilder::includeFile(const std::filesystem::path &filename) {
  std::fstream in(filename.native(), std::fstream::in);
  std::stringstream error;
  error << "While parsing the file " << filename;

  NncErrorLocation l(error.str());

  std::unique_ptr<ArchDescLexer> lexer(makeLexer(filename, in));
  nnc::parser parser(*lexer, *this);
  m_lexers.insert({filename, std::move(lexer)});

  parser();
}

void ArchDescBuilder::addCHeader(const std::string &chunk) {
  m_cheaders.push_back(chunk);
}

void ArchDescBuilder::addInsnRule(InsnRule *r) {
  m_rules.emplace_back(r);
}

void ArchDescBuilder::addInsn(Insn *i) {
  m_insns.emplace_back(i);
}

void ArchDescBuilder::addRegister(Register *r) {
  std::unique_ptr<Register> uniq(r);
  m_registers[uniq->name()] = std::move(uniq);
}

void ArchDescBuilder::addRegisterClass(RegClass *rc) {
  std::unique_ptr<RegClass> uniq(rc);
  m_regClass[uniq->name()] = std::move(uniq);
}

void ArchDescBuilder::generate(const std::filesystem::path &base) {
  std::filesystem::path output(base);
  output /= std::filesystem::path("arch") / cArchName();

  FilesystemGenerator fs(output);

  generate(fs);
}

void ArchDescBuilder::generate(GenerateVisitor &v) {
  // Generate headers
  v.generate("schedule.hpp", std::bind(&ArchDescBuilder::generateScheduleHeader, this, std::placeholders::_1));
  v.generate("insns.hpp", std::bind(&ArchDescBuilder::generateInsnsHeader, this, std::placeholders::_1));
  v.generate("rules.cpp", std::bind(&ArchDescBuilder::generateRuleImpl, this, std::placeholders::_1));
  v.generate("insns.cpp", std::bind(&ArchDescBuilder::generateInsnsImpl, this, std::placeholders::_1));
}

void ArchDescBuilder::generateInsnsImpl(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardImpl h(out);

  h.noindent() << "#include \"arch/" << cArchName() << "/insns.hpp\"" << std::endl;
  h.noindent() << "#include \"exception.hpp\"" << std::endl;
  h.noindent() << "#include \"compile/rtl_ops.hpp\"" << std::endl;
  h.noindent() << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("insn");

  for ( const auto &insn : m_insns ) {
    std::string clsNm(cName(insn->name()));
    h.indent() << clsNm << "::";
    insn->declareConstructor(clsNm, h.noindent()) << std::endl;

    h.indent(1) << ": ::nnc::compile::RtlOp(\"" << insn->name() << "\")" << std::endl;
    for ( const auto &arg : insn->args() ) {
      h.indent(1) << ", " << "m_" << cName(arg.name(), false) << "(" << cName(arg.name()) << ")" << std::endl;
    }
    h.indent() << "{" << std::endl;
    for ( const auto &arg: insn->args() ) {
      if ( arg.type().isDefaultable() && arg.optional() ) {
        IndentedHeader lines(h, 1);
        arg.type().outputArgMakeDefault("_fn", "m_" + cName(arg.name()), cName(arg.name()), lines);
        lines.noindent() << std::endl;
      }
    }
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declDestructor(clsNm) << " {" << std::endl;
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declMember("void", clsNm, "operands").arg("::nnc::compile::RtlOperandVisitor &v")._const() << "{" << std::endl;
    for ( const auto &arg : insn->args() ) {
      arg.type().outputVisitOperand("v", arg.name(), "m_" + cName(arg.name()), arg.direction(),
                                    h.indent(1));
    }
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declMember("void", clsNm, "operand").arg("const std::string &nm").arg("std::shared_ptr<::nnc::compile::RtlVariable> var") << "{" << std::endl;
    for ( const auto &arg : insn->args() ) {
      h.indent(1) << "if (nm == \"" << arg.name() << "\") {" << std::endl;
      h.indent(2) << "m_" << cName(arg.name(), false) << " = var;" << std::endl;
      h.indent(1) << "}" << std::endl;
    }
    h.indent(1) << "throw exception::RtlOpArgDoesNotExist(nm);" << std::endl;
    h.indent() << "}" << std::endl << std::endl;
  }
}

void ArchDescBuilder::generateApply(InsnRule &rule, const IndentedHeaderBase &h) {
  std::set<std::string> m_handled;

  h.indent() << "::nnc::compile::RtlFunction &fn(sel.function());" << std::endl;
  h.indent() << cName(rule.name()) << " *newRule;" << std::endl;

  MnemonicsCollector c;
  rule.pats().declMnemonicInterest(c);

  bool first(true);
  for ( const auto &mn: c ) {
    (first ? h.indent() : (h.noindent() << " else "))
      << "if ( strcmp(op.mnemonic(), \"" << mn << "\") == 0 ) {" << std::endl;

    MnemonicApplyGen gen(mn, rule, h);
    rule.pats().visitPatterns(gen);

    h.indent() << "}";

    first = false;
  }

  h.noindent() << std::endl;
}

void ArchDescBuilder::generateRuleMatchers(InsnRule &rule, IndentedHeaderBase &hdr) {
  RuleMatcherGen gen(rule, hdr);
  rule.pats().visitPatterns(gen);
}

void ArchDescBuilder::generateScheduleHeader(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardHeader h(out, *this, "schedule");
  h.indent() << "#include \"compile/genericschedule.hpp\"" << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("schedule");

  std::string scheduleClsNm("block_scheduler");

  h.indent() << "class " << scheduleClsNm << " : public ::nnc::compile::GenericScheduler {" << std::endl;
  h.indent() << "public:";
  h.indent(1) << scheduleClsNm << "(::nnc::compile::RtlFunction &dst, std::shared_ptr<::nnc::compile::RtlBasicBlock> b);" << std::endl;
  h.indent(1) << "virtual ~" << scheduleClsNm << "();" << std::endl;
  h.noindent() << std::endl;
  h.indent() << "protected:" << std::endl;
  h.indent(1) << "virtual void buildPatterns(::nnc::compile::InsnSelector &sel);" << std::endl;
  h.indent() << "};" << std::endl << std::endl;

  std::string fnScheduleClsNm("scheduler");
  h.indent() << "class " << fnScheduleClsNm << " : public ::nnc::compile::GenericFunctionScheduler {" << std::endl;
  h.indent() << "public:" << std::endl;
  h.indent(1) << fnScheduleClsNm << "(::nnc::compile::RtlFunction &src);" << std::endl;
  h.indent(1) << "virtual ~" << fnScheduleClsNm << "();" << std::endl << std::endl;
  h.indent() << "protected:" << std::endl;
  h.indent(1) << "virtual std::unique_ptr<::nnc::compile::GenericScheduler> makeBlockScheduler(std::shared_ptr<::nnc::compile::RtlBasicBlock> block);" << std::endl;
  h.indent() << "};" << std::endl;
}


void ArchDescBuilder::generateInsnsHeader(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardHeader h(out, *this, "insns");
  h.indent() << "#include \"compile/rtl.hpp\"" << std::endl;
  h.indent() << "#include \"compile/rtl_ops_base.hpp\"" << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("insn");

  for ( const auto &insn : m_insns ) {
    h.indent() << "class " << cName(insn->name()) << " : public ::nnc::compile::RtlOp {" << std::endl;
    h.indent() << "public:" << std::endl;
    insn->declareConstructor(cName(insn->name()), h.indent(1), true) << ";" << std::endl;
    h.indent(1) << "virtual ~" << cName(insn->name()) << "();" << std::endl;

    h.noindent() << std::endl;
    // RtlOp functions
    h.indent(1) << "virtual void operands(::nnc::compile::RtlOperandVisitor &v) const;" << std::endl;
    h.indent(1) << "virtual void operand(const std::string &nm, std::shared_ptr<::nnc::compile::RtlVariable> var);" << std::endl;

    h.noindent() << std::endl;

    h.indent() << "private:" << std::endl;
    for ( const auto &arg : insn->args() ) {
      std::ostream &line(h.indent(1));
      arg.type().outputCType(line) << " m_" << cName(arg.name(), false) << ";" << std::endl;
    }
    h.indent() << "};" << std::endl;
  }

}

void ArchDescBuilder::generateRuleImpl(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardImpl h(out);

  h.noindent() << "#include \"compile/insnsel.hpp\"" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/schedule.hpp\"" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/insns.hpp\"" << std::endl;
  h.noindent() << std::endl;
  h.noindent() << "#include <algorithm>" << std::endl;
  h.noindent() << "#include <functional>" << std::endl;
  h.noindent() << "#include <memory>" << std::endl;
  h.noindent() << "#include <span>" << std::endl;
  h.noindent() << "#include <cstring>" << std::endl;
  h.noindent() << "#include <string>" << std::endl;

  codeSection(h.noindent(), "rules_preamble");

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("rules");

  codeSection(h.noindent(), "rules_preamble_namespaced");

  for ( const auto &rule : m_rules ) {
    generateRuleMatchers(*rule, h);
    std::map<std::string, std::string> varNms;
    for ( const auto &var : rule->vars() ) {
      std::stringstream ref;

      ref << "(this->var_" << cName(var.first) << ")";

      varNms.emplace(var.first, ref.str());
    }

    MnemonicsCollector mnemonics;
    rule->pats().visitPatterns(mnemonics);

    h.indent() << "class " << cName(rule->name()) << " : public virtual ::nnc::compile::InsnSelRule, public virtual ::nnc::compile::SelectedInsn {" << std::endl;
    h.indent() << "public:" << std::endl;

    // Default constructor
    h.indent(1) << cName(rule->name()) << "()" << std::endl;
    bool first(true);
    for ( const auto &var : rule->vars() ) {
      if ( var.second.type() != InsnVariable::ConstantType ) {
        h.indent(1) << (first ? ": " : ", ") << "var_" << cName(var.first) << "(nullptr)" << std::endl;
        first = false;
      }
    }
    h.indent(1) << "{" << std::endl;
    h.indent(2) << "std::fill(std::begin(ops), std::end(ops), nullptr);" << std::endl;
    if ( mnemonics.hasBranches() )
      h.indent(2) << "std::fill(std::begin(branches), std::end(branches), 0);" << std::endl;
    h.indent(1) << "}" << std::endl;

    // Copy constructor
    h.indent(1) << cName(rule->name()) << "(const " << cName(rule->name()) << "& o)" << std::endl;
    first = true;
    for ( const auto &var : rule->vars() ) {
      h.indent(1) << (first ? ": " : ", ") << "var_" << cName(var.first) << "(o.var_" << cName(var.first) << ")" << std::endl;
      first = false;
    }
    h.indent(1) << "{" << std::endl;
    h.indent(2) << "std::copy(std::begin(o.ops), std::end(o.ops), std::begin(ops));" << std::endl;
    if ( mnemonics.hasBranches() )
      h.indent(2) << "std::copy(std::begin(o.branches), std::end(o.branches), std::begin(branches));" << std::endl;
    h.indent(1) << "}" << std::endl;

    h.indent(1) << "virtual ~" << cName(rule->name()) << "() { }" << std::endl << std::endl;

    // InsnSelRule
    h.indent(1) << "virtual void apply(::nnc::compile::InsnSelector &sel, ::nnc::compile::RtlOp &op) const {" << std::endl;
    generateApply(*rule, IndentedHeader(h, 2));
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "virtual void registerInterest(::nnc::compile::InterestRecorder &r) const {" << std::endl;
    for ( const std::string &mnemonic : mnemonics ) {
      h.indent(2) << "r.instruction(\"" << mnemonic << "\");" << std::endl;
    }
    h.indent(1) << "}" << std::endl << std::endl;

    // SelectedInsn
    h.indent(1) << "virtual void consumedOperations(::nnc::compile::RtlOpMarker &marker) const {" << std::endl;
    h.indent(2) << "for ( int i = 0; i < " << mnemonics.patternCount() << "; ++i) {" << std::endl;
    h.indent(3) << "if (ops[i]) marker.matchOp(ops[i]);" << std::endl;
    h.indent(2) << "}" << std::endl;
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "virtual void build(::nnc::compile::RtlBasicBlock &compiled) const {" << std::endl;
    for ( const auto &g : rule->generated() ) {
      auto &insn(lookupInsn(g.mnemonic(), g.errorContext()));

      h.indent(2) << "compiled.emplace_op<" << cInsnName(g.mnemonic()) << ">(compiled.function()";
      std::set<std::string> argsReceived;
      auto sig(insn.args().begin());
      std::vector<std::optional<std::string>> args(insn.args().size());
      auto out(args.begin());

      for ( auto arg(g.args().begin());
            arg != g.args().end();
            ++arg, ++sig, ++out ) {
        if ( sig == insn.args().end() )
          throw NncGenerationError(g.errorContext(), "Arity mismatch in call to " + g.mnemonic());

        std::stringstream argStr;
        argStr << arg->render(varNms);
        *out = argStr.str();
        argsReceived.insert(sig->name());
      }

      // Now apply named arguments
      for ( const auto &namedArg : g.namedArgs() ) {
        // If we've already passed this arg error
        if ( argsReceived.find(namedArg.first) != argsReceived.end() ) {
          throw NncGenerationError(g.errorContext(), "Argument " + namedArg.first + " already passed to " + g.mnemonic());
        }

        // Make sure this argument exists
        auto argSig(std::find_if(sig, insn.args().end(), [&namedArg](const auto &argsig) { return argsig.name() == namedArg.first; }));
        if ( argSig == insn.args().end() ) {
          throw NncGenerationError(g.errorContext(), "Named argument " + namedArg.first + " does not exist in " + g.mnemonic());
        }

        std::stringstream argStr;
        argStr << namedArg.second.render(varNms);
        *(out + std::distance(sig, argSig)) = argStr.str();
        argsReceived.insert(namedArg.first);
      }

      // Make sure all required args were inserted
      for ( const auto &arg: insn.args() ) {
        if ( !arg.optional() && argsReceived.find(arg.name()) == argsReceived.end() )
          throw NncGenerationError(g.errorContext(), "Insn call " + g.mnemonic() + " called without arg " + arg.name());
      }

      auto lastArg(std::find_if(std::make_reverse_iterator(args.end()), std::make_reverse_iterator(args.begin()),
                                [](const auto &arg) { return arg.has_value(); }));
      args.erase(lastArg.base(), args.end());

      sig = insn.args().begin();
      for ( decltype(args)::iterator arg(args.begin());
            arg != args.end();
            ++ arg, ++sig ) {
        if ( arg->has_value() ) {
          h.noindent() << ", " << **arg;
        } else if ( sig->optional() ) {
          h.noindent() << ", ";
          if ( sig->type().isDefaultable() )
            sig->type().outputArgDefault(h.noindent());
          else
            throw NncGenerationError(g.errorContext(), "Argument " + sig->name() + " is optional, but not defaultable");
        } else {
          throw NncGenerationError(g.errorContext(), "Insn call " + g.mnemonic() + " called without required arg " + sig->name());
        }
      }

      h.noindent() << ");" << std::endl;
    }
    h.indent(1) << "}" << std::endl << std::endl;


    h.indent() << "private:" << std::endl;
    h.indent(1) << "bool complete() const {" << std::endl;

    IndentedHeader ch(h, 2);
    CompleteGen g(ch);
    rule->pats().visitPatterns(g);
    g.finish();

//    h.indent(2) << "return std::all_of(std::begin(ops), std::end(ops), [](::nnc::compile::RtlOp *p) { return !!p; });" << std::endl;
    h.indent(1) << "}" << std::endl << std::endl;
    h.indent(1) << "bool canContinue() const {" << std::endl;
    h.indent(2) << "return !complete();" << std::endl;
    h.indent(1) << "}" << std::endl << std::endl;
    h.indent(1) << "bool check() {" << std::endl;
    for ( const auto &cond : rule->conds() ) {
      h.indent(2) << "if ( !(" << cond.render(varNms) << ")) {" << std::endl;
      h.indent(3) << "return false;" << std::endl;
      h.indent(2) << "}" << std::endl;
    }
    h.indent(2) << "return true;" << std::endl;
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "::nnc::compile::RtlOp *ops[" << mnemonics.patternCount() << "];" << std::endl;
    if ( mnemonics.hasBranches() )
      h.indent(1) << "int branches[" << mnemonics.branchCount() << "];" << std::endl;

    for ( const auto &var : rule->vars() ) {
      declVar(var.first, var.second.type(), IndentedHeader(h, 1));
    }

    rule->extraPrivate().render(varNms).emit_by_lines(IndentedHeader(h, 1));

    h.indent() << "};" << std::endl;
  }

  h.popNamespace();
  h.pushNamespace("schedule");

  std::string scheduleClsNm("block_scheduler");
  h.indent() << scheduleClsNm << "::" << scheduleClsNm << "(::nnc::compile::RtlFunction &dst, std::shared_ptr<::nnc::compile::RtlBasicBlock> b)" << std::endl;
  h.indent(1) << ": ::nnc::compile::GenericScheduler(dst, b) {" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << scheduleClsNm << "::~" << scheduleClsNm << "() {" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "void " << scheduleClsNm << "::buildPatterns(::nnc::compile::InsnSelector &sel) {" << std::endl;
  for ( const auto &rule: m_rules ) {
    h.indent(1) << "sel.addRule(std::make_unique<rules::" << cName(rule->name()) << ">());" << std::endl;
  }
  h.indent() << "}" << std::endl;

  std::string fnScheduleClsNm("scheduler");
  h.indent() << fnScheduleClsNm << "::" << fnScheduleClsNm << "(::nnc::compile::RtlFunction &src)" << std::endl;
  h.indent(1) << ": ::nnc::compile::GenericFunctionScheduler(src)" << std::endl;
  h.indent() << "{" << std::endl;
  h.indent() << "}" << std::endl << std::endl;;

  h.indent() << declDestructor(fnScheduleClsNm) << std::endl;
  h.indent() << "{" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() <<
    declMember("std::unique_ptr<::nnc::compile::GenericScheduler>", fnScheduleClsNm, "makeBlockScheduler")
    .arg("std::shared_ptr<::nnc::compile::RtlBasicBlock> block") << std::endl;
  h.indent() << "{" << std::endl;
  h.indent(1) << scheduleClsNm << " *scheduler(new " << scheduleClsNm << "(function(), block));" << std::endl;
  h.indent(1) << "return std::unique_ptr<::nnc::compile::GenericScheduler>(static_cast<::nnc::compile::GenericScheduler *>(scheduler));" << std::endl;
  h.indent() << "}" << std::endl;

  codeSection(h.noindent(), "rules_postamble_namespaced");
}

void ArchDescBuilder::addCType(const std::string &name, CType *c) {
  m_cTypes.insert(std::make_pair(name, std::unique_ptr<CType>(c)));
}

CType &ArchDescBuilder::cType(const std::string &nm) {
  auto it(m_cTypes.find(nm));
  if ( it == m_cTypes.end() )
    throw NncParseError("C type " + nm + " not found");

  return *it->second;
}

void ArchDescBuilder::addCodeSection(const std::string &sectionName, const std::string &contents) {
  m_codeSections.insert(std::make_pair(sectionName, contents));
}

void ArchDescBuilder::codeSection(std::ostream &out, const std::string &sectionName) {
  auto r(m_codeSections.equal_range(sectionName));
  std::transform(r.first, r.second, std::ostream_iterator<std::string>(out, "\n"), [](const auto &k) { return k.second; });
}

Insn &ArchDescBuilder::lookupInsn(const std::string &nm, const NncErrorContextStack &fromWhere) {
  auto found(std::find_if(m_insns.begin(), m_insns.end(), [&nm] (const auto &insn) { return insn->name() == nm; }));
  if ( found == m_insns.end() )
    throw NncGenerationError(fromWhere, "Could not find instruction " + nm);

  return **found;
}

void declVar(const std::string &name, InsnVariable::Type typ,
             const IndentedHeaderBase &h) {
  auto &out(h.indent());
  switch ( typ ) {
  case InsnVariable::RegisterType:
    out << "std::shared_ptr<::nnc::compile::RtlVariable> ";
    break;

  case InsnVariable::RegTypeType:
    out << "std::shared_ptr<::nnc::compile::RtlType> ";
    break;

  case InsnVariable::ConstantType:
    out << "std::span<std::uint8_t> ";
    break;
  }
  out << "var_" << cName(name) << ";" << std::endl;
}

std::string ArchDescBuilder::cArchName() const {
  if ( m_name ) return cName(*m_name);
   else return "";
}

void ArchDescBuilder::includeCHeaders(std::ostream &out) const {
  for ( const auto &h: m_cheaders ) {
    out << h;
  }
}

std::string cName(const std::string &orig, bool full) {
  std::string ret(orig);
  for ( auto &c : ret ) {
    if ( !isalpha(c) && !isdigit(c) && c != '_' )
      c = '_';
  }
  if ( full && (ret == "and" || ret == "and_eq" ||
                ret == "bitand" || ret == "bitor" ||
                ret == "compl" || ret == "not" ||
                ret == "not_eq" || ret == "or" ||
                ret == "or_eq" || ret == "xor" ||
                ret == "xor_eq") ) {
    ret.insert(0, "c_");
  }
  return ret;
}

std::string cInsnName(const std::string &orig) {
  std::stringstream s;
  s << "insn::" << cName(orig);
  return s.str();
}
