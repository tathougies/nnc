#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <cctype>
#include <iterator>

#include "parser.hpp"
#include "archdesc.hpp"

class declDestructor {
public:
  declDestructor(const std::string &nm)
    : name(nm) {
  }

  const std::string &name;
};

std::ostream &operator<<(std::ostream &out, const declDestructor &d) {
  out << d.name << "::~" << d.name << "()";
  return out;
}

class declMember {
public:
  declMember(const std::string &ty, const std::string &clsNm, const std::string &fnName)
    : m_type(ty), m_clsNm(clsNm), m_fnName(fnName), m_isConst(false) {
  }

  declMember &_const () { m_isConst = true; return *this; }
  declMember &arg(const std::string &arg) {
    if ( m_args.tellp() > 0 ) m_args << ", ";
    m_args << arg;
    return *this;
  }

  const std::string &m_type;
  const std::string &m_clsNm;
  const std::string &m_fnName;

  std::stringstream m_args;
  bool m_isConst;
};

std::ostream &operator<<(std::ostream &out, const declMember &d) {
  out << d.m_type << " " << d.m_clsNm << "::" << d.m_fnName << "(" << d.m_args.str() << ") ";
  if ( d.m_isConst )
    out << "const ";
  return out;
}

class StandardImpl : public IndentedHeaderBase {
public:
  StandardImpl(std::ostream &out)
    : m_out(out), m_namespaces(0) {
    m_out << "/* This file is auto-generated by archdescc. Do not modify */" << std::endl;
  }

  ~StandardImpl() {
    popAllNamespaces();
  }

  void pushNamespace(const std::string &n) {
    indent() << "namespace " << n << " {" << std::endl;
    m_namespaces++;
  }

  void popNamespace() {
    m_namespaces--;
    indent() << "}" << std::endl;
  }

  void popAllNamespaces() {
    while ( m_namespaces > 0 ) popNamespace();
  }

  virtual std::ostream &noindent() const { return m_out; }

  virtual std::ostream &indent(int extra = 0) const {
    int spaces = (m_namespaces + extra) * 2;
    std::fill_n(std::ostream_iterator<char>(m_out), spaces, ' ');
    return m_out;
  };

  virtual std::string var(const std::string &base) {
    auto it (m_vars.find(base));
    if ( it == m_vars.end() ) {
      m_vars.insert(std::make_pair(base, 1));
      return base + "0";
    } else {
      std::stringstream vn;
      vn << base << it->second;
      it->second++;
      return vn.str();
    }
  }

protected:
  std::ostream &m_out;
  int m_namespaces;
  std::map<std::string, int> m_vars;
};

class StandardHeader : public StandardImpl {
public:
  StandardHeader(std::ostream &out, ArchDescBuilder &b, const std::string &what)
    : StandardImpl(out) {
    m_out << "#ifndef __nnc_compile_" << b.cArchName() << "_" << what << "_HPP__" << std::endl;
    m_out << "#define __nnc_compile_" << b.cArchName() << "_" << what << "_HPP__" << std::endl;
    m_out << std::endl;
    b.includeCHeaders(m_out);
    m_out << std::endl;
  }

  ~StandardHeader() {
    popAllNamespaces();
    m_out << "#endif" << std::endl;
  }
};

class IndentedHeader : public IndentedHeaderBase {
public:
  IndentedHeader(IndentedHeaderBase &b, int n = 1)
    : m_base(b), m_n(n) {
  }

  virtual std::ostream &indent(int extra = 0) const {
    return m_base.indent(extra + m_n);
  }
  virtual std::ostream &noindent() const { return m_base.noindent(); }

  virtual std::string var(const std::string &base) {
    return m_base.var(base);
  }

private:
  IndentedHeaderBase &m_base;
  int m_n;
};

class MnemonicsCollector : public MnemonicInterestDeclarer, public InsnPatternVisitor {
private:
  std::set<std::string> m_mnemonics;
  int m_patternCount, m_branchCount;

  struct branch {
  public:
    branch(): altCount(0), subCount(0), maxSubCount(0) { }

    void pushAlt() {
      if ( subCount > maxSubCount ) maxSubCount = subCount;
      subCount = 0;
    }

    int curSubCount() const { return (maxSubCount > subCount ? maxSubCount : subCount); }

    int altCount, subCount, maxSubCount;
  };
  std::vector<branch> m_branches;

public:
  typedef decltype(m_mnemonics)::iterator iterator;
  MnemonicsCollector() : m_patternCount(0), m_branchCount(0) {
  }
  virtual ~MnemonicsCollector() {
  }

  iterator begin() { return m_mnemonics.begin(); }
  iterator end() { return m_mnemonics.end(); }

  virtual void declareInterest(const std::string &mn) {
    m_mnemonics.insert(mn);
  }

  virtual void visit(const InsnPattern &p) {
    p.declMnemonicInterest(*this);
    m_patternCount++;
  }

  virtual void newBranch() {
    if ( m_branches.empty() ) m_branchCount ++;
    else m_branches.back().subCount ++;

    m_branches.emplace_back();
  }

  virtual void newAlternative() {
    m_branches.back().altCount++;
    m_branches.back().pushAlt();
  }

  virtual void endBranch() {
    int sub(m_branches.back().curSubCount());
    m_branches.pop_back();

    if ( !m_branches.empty() )
      m_branches.back().subCount += sub;
    else
      m_branchCount += sub;
  }

  inline int branchCount() const { return m_branchCount; }
  inline bool hasBranches() const { return branchCount() > 0; }
  inline int patternCount() const { return m_patternCount; }
};

class VariableCollector : public InsnVariableVisitor {
public:
  VariableCollector(InsnRule &rule)
    : m_rule(rule) {
  }

  virtual void visit(const std::string &name, bool isType) {
    if ( !m_rule.has_var(name) ) {
      std::stringstream err;
      err << "Rule has no variable named " << name;
      throw NncGenerationError(m_rule.errorContext(), err);
    } else {
      auto &var(m_rule.var(name));
      if ( isType && var.type() != InsnVariable::RegTypeType )  {
        std::stringstream err;
        err << "Variable " << name << " used in type position, but it's not a type";
        throw NncGenerationError(m_rule.errorContext(), err);
      }

      m_vars[name] = &var;
    }
  }

  typedef std::map<std::string, InsnVariable *> variables_type;
  variables_type &all() { return m_vars; }
private:
  InsnRule &m_rule;
  variables_type m_vars;
};

class RuleMatcherGen : public InsnPatternVisitor {
public:
  RuleMatcherGen(InsnRule &rule, IndentedHeaderBase &hdr)
    : m_insnNum(0), m_rule(rule), m_header(hdr) {
  }
  virtual ~RuleMatcherGen() {}

  virtual void visit(const InsnPattern &p) {
    std::stringstream clsnm;
    InsnRule &rule(m_rule);
    IndentedHeaderBase &hdr(m_header);
    int insnnum(m_insnNum);

    clsnm << cName(rule.name()) << "_operand_" << insnnum << "_matcher";
    hdr.indent() << "class " << clsnm.str() << " : public virtual ::nnc::compile::RtlOperandVisitor {" << std::endl;
    hdr.indent() << "public:" << std::endl;
    hdr.indent(1) << clsnm.str() << "(::nnc::compile::RtlFunction &fn)" << std::endl;

    VariableCollector vars(rule);
    // Collect variables
    p.visitVars(vars);

    hdr.indent(1) << ": RtlOperandVisitor(fn)" << std::endl;
    for ( const auto &var : vars.all() ) {
      if ( var.second->type() != InsnVariable::ConstantType ) {
        hdr.indent(1) << ", var_" << cName(var.first) << "(nullptr)" << std::endl;
      }
    };

    hdr.indent(1) << "{ }" << std::endl << std::endl;

    hdr.indent(1) << "bool complete() const {" << std::endl;
    for ( const auto &var : vars.all() ) {
      switch ( var.second->type() ) {
      case InsnVariable::ConstantType:
        hdr.indent(2) << "if ( !var_" << cName(var.first) << ".data() )";
        break;

      case InsnVariable::RegTypeType:
      case InsnVariable::RegisterType:
        hdr.indent(2) << "if ( !var_" << cName(var.first) << " )";
        break;
      }

      hdr.noindent() << " return false;" << std::endl;
    }
    hdr.indent(2) << "return true;" << std::endl;
    hdr.indent(1) << "}" << std::endl << std::endl;

    hdr.indent(1) << "virtual void operand(const std::string &name, const ::nnc::compile::RtlBlockName &dest) { }" << std::endl << std::endl;

    hdr.indent(1) << "virtual void operand(const std::string &name, std::shared_ptr<::nnc::compile::RtlVariable> var, bool input, bool output) {" << std::endl;

    for ( const auto &arg : p.args() ) {
      if ( rule.var(arg.second.var()).type() == InsnVariable::RegisterType ) {
        hdr.indent(2) << "if ( name == \"" << arg.first << "\" ) {" << std::endl;
        hdr.indent(3) << "var_" << cName(arg.second.var()) << " = var;" << std::endl;
        if ( arg.second.tyVar() ) {
          hdr.indent(3) << "var_" << cName(*arg.second.tyVar()) << " = var->type();" << std::endl;
        }
        hdr.indent(2) << "}" << std::endl;
      }
    }

    hdr.indent(1) << "}" << std::endl << std::endl;

    hdr.indent(1) << "virtual void operand(const std::string &name, std::shared_ptr<::nnc::compile::RtlType> ty, const void *l, std::size_t lsz) {" << std::endl;
    for ( const auto &arg : p.args() ) {
      if ( rule.var(arg.second.var()).type() == InsnVariable::ConstantType ) {
        hdr.indent(2) << "if ( name == \"" << arg.first << "\" ) {" << std::endl;
        hdr.indent(3) << "var_" << cName(arg.second.var()) << " = std::span<std::uint8_t>((std::uint8_t *)l, lsz);" << std::endl;
        if ( arg.second.tyVar() ) {
          hdr.indent(3) << "var_" << cName(*arg.second.tyVar()) << " = ty;" << std::endl;
        }
        hdr.indent(2) << "}" << std::endl;
      }
    }
    hdr.indent(1) << "}" << std::endl;

    for ( const auto &var: vars.all() ) {
      IndentedHeader b(hdr, 1);
      declVar(var.first, var.second->type(), b);
    }

    hdr.indent() << "};" << std::endl << std::endl;

    m_insnNum++;
  }

private:
  int m_insnNum;

  InsnRule &m_rule;
  IndentedHeaderBase &m_header;
};

class MnemonicApplyGen : public InsnPatternVisitor {
private:
  struct branch {
    branch(int i) : baseIx(i), nextBaseIx(i), maxSubCount(0), subCount(0), altNum(0) { }

    void updateSubCount() {
      if ( subCount > maxSubCount ) maxSubCount = subCount;
      subCount = 0;
    }

    void nextAlt() {  altNum++; }
    void outputCondition(std::ostream &o) const {
      o << "(branches[" << baseIx << "] == 0 || branches[" << baseIx << "] == " << altNum << ")";
    }
    void updateRule(std::ostream &o, const std::string &what) const {
      o << what << ".branches[" << baseIx << "] = " << altNum << ";" << std::endl;
    }

    int baseIx, nextBaseIx, maxSubCount, subCount, altNum;
  };

public:
  MnemonicApplyGen(const std::string &mn, InsnRule &rule, const IndentedHeaderBase &b)
    : m_insnNum(0), m_branchNum(0), m_mnemonic(mn), m_rule(rule), m_header(b) {
  }
  virtual ~MnemonicApplyGen() {
  }

  std::ostream &curBranchCondition(std::ostream &o) const {
      for ( const auto &br: m_branches ) {
        o << " && ";
        br.outputCondition(o);
      }
      return o;
  }

  virtual void visit(const InsnPattern &p) {
    if ( p.mnemonic() == m_mnemonic ) {
      int insnnum(m_insnNum);
      const IndentedHeaderBase &h(m_header);
      InsnRule &rule(m_rule);

      h.indent(1) << "if ( !ops[" << insnnum << "]";
      curBranchCondition(h.noindent()) << ") {" << std::endl;
      h.indent(2) << cName(rule.name()) << "_operand_" << insnnum << "_matcher matcher(fn);" << std::endl;
      h.indent(2) << "op.operands(matcher);" << std::endl;

      VariableCollector vars(rule);
      p.visitVars(vars);

      h.indent(2) << "if ( matcher.complete() ) {" << std::endl;
      // Now check each argument
      h.indent(3) << cName(rule.name()) << " newRule(*this);" << std::endl;

      // Update branches
      for (const auto &br: m_branches)
        br.updateRule(h.indent(3), "newRule");

      for ( const auto &var : vars.all() ) {
        std::stringstream v;
        v << "var_" << cName(var.first);

        switch ( var.second->type() ) {
        case InsnVariable::ConstantType:
          h.indent(3) << "if ( " << v.str() << ".data() && !std::equal(std::begin(" << v.str() << "), std::end(" << v.str() << "), std::begin(matcher." << v.str() << "), std::end(matcher." << v.str() << ")) ) goto skip_insn_" << insnnum << ";" << std::endl;
          h.indent(3) << "else if ( !" << v.str() << ".data() ) newRule." << v.str() << " = matcher." << v.str() << ";" << std::endl;
          break;

        case InsnVariable::RegisterType:
          h.indent(3) << "if ( var_" << cName(var.first) << " && !(var_" << cName(var.first) << "->isSame(matcher.var_" << cName(var.first) << ")) ) goto skip_insn_" << insnnum << ";" << std::endl;
          h.indent(3) << "else if ( !var_" << cName(var.first) << ") newRule.var_" << cName(var.first) << " = matcher.var_" << cName(var.first) << ";" << std::endl << std::endl;
          break;

        default:
          h.indent(3) << "if ( var_" << cName(var.first) << " && var_" << cName(var.first) << "!= matcher.var_" << cName(var.first) << " ) goto skip_insn_" << insnnum << ";" << std::endl;
          h.indent(3) << "else if ( !var_" << cName(var.first) << ") newRule.var_" << cName(var.first) << " = matcher.var_" << cName(var.first) << ";" << std::endl << std::endl;
          break;
        };
      }

      h.indent(3) << "newRule.ops[" << insnnum << "] = &op;" << std::endl;
      h.indent(3) << "if ( newRule.complete() ) {" << std::endl;
      h.indent(4) << "if ( newRule.check(fn) ) {" << std::endl;
      h.indent(5) << "auto *selected(new " << cName(rule.name()) << "(newRule));" << std::endl;
      h.indent(5) << "std::unique_ptr<::nnc::compile::SelectedInsn> selInsnPtr(static_cast<::nnc::compile::SelectedInsn *>(selected));" << std::endl;
      h.indent(5) << "sel.markInsnSchedulable(std::move(selInsnPtr));" << std::endl;
      h.indent(4) << "}" << std::endl;
      h.indent(3) << "}" << std::endl;
      h.indent(3) << "if ( newRule.canContinue() ) {" << std::endl;
      h.indent(4) << "auto *nextInsn(new " << cName(rule.name()) << "(newRule));" << std::endl;
      h.indent(4) << "std::unique_ptr<::nnc::compile::InsnSelRule> newRulePtr(static_cast<::nnc::compile::InsnSelRule *>(nextInsn));" << std::endl;
      h.indent(4) << "sel.addRule(std::move(newRulePtr));" << std::endl;
      h.indent(3) << "}" << std::endl;
      h.indent(2) << "skip_insn_" << insnnum << ":" << std::endl;
      h.indent(3) << "(void)0;" << std::endl;
      h.indent(2) << "}" << std::endl;
      h.indent(1) << "}" << std::endl;
    }

    ++m_insnNum;
  }

  virtual void newBranch() override {
    if ( m_branches.empty() ) {
      m_branches.emplace_back(m_branchNum);
      m_branchNum++;
    } else {
      m_branches.back().subCount ++;
      m_branches.emplace_back(m_branches.back().nextBaseIx + 1);
    }
  }

  virtual void newAlternative() override {
    m_branches.back().updateSubCount();
    m_branches.back().nextAlt();
  }

  virtual void endBranch() override {
    m_branches.back().updateSubCount();
    int sub(m_branches.back().maxSubCount);
    m_branches.pop_back();

    if ( m_branches.empty() ) m_branchNum += sub;
    else {
      m_branches.back().nextBaseIx += sub;
      m_branches.back().subCount += sub;
    }
  }

private:
  int m_insnNum, m_branchNum;
  const std::string &m_mnemonic;
  InsnRule &m_rule;
  const IndentedHeaderBase &m_header;

  std::vector<branch> m_branches;
};

class CompleteExpr {
public:
  enum ExprType { Disjunction, Conjunction };
  CompleteExpr(CompleteExpr *parent, ExprType ty)
    : m_parent(parent), m_final(parent->m_final), m_first(true), m_tautology(false), m_type(ty), m_startIx(-1), m_endIx(-1) {
  }
  CompleteExpr(std::ostream &out, ExprType ty)
    : m_parent(nullptr), m_final(out), m_first(true), m_tautology(false), m_type(ty), m_startIx(-1), m_endIx(-1) {
  }

  ~CompleteExpr() {
    flushRange();

    bool def(m_type == Conjunction);
    if ( m_tautology ) def = !def;

    if ( m_first ) {
      if ( m_parent ) m_parent->constant(def);
      else m_final << (def ? "true" : "false");
    } else {
      if ( m_parent && !m_parent->m_tautology ) {
        if ( !m_parent->m_first ) m_parent->m_out << m_parent->oper();
        m_parent->m_out << "(" << m_out.str() << ")";
        m_parent->m_first = false;
      } else m_final << "(" << m_out.str() << ")";
    }
  }

  void include(int ix) {
    if ( m_tautology ) return;

    if ( m_startIx < 0 ) { m_startIx = ix; m_endIx = ix + 1; }
    else if ( ix == m_endIx ) { m_endIx = ix + 1; }
    else flushRange();
  }

  void constant(bool d) {
    if ( (m_type == Disjunction && d) ||
         (m_type == Conjunction && !d ) ) {
      m_tautology = true;
      m_first = true;
      m_out.str("");
    }
  }

  inline ExprType type() const { return m_type; }
  inline CompleteExpr *parent() const { return m_parent; }

private:
  void flushRange() {
    if ( m_startIx >= 0 && m_endIx > m_startIx ) {
      if ( !m_first ) m_out << oper();
      if ( (m_endIx - m_startIx) == 1 ) {
        m_out << "ops[" << m_startIx << "]";
      } else {
        m_out << "std::all_of(ops + " << m_startIx
              << ", ops + " << m_endIx
              << ", std::identity())";
      }
      m_startIx = m_endIx = -1;
      m_first = false;
    }
  }

  const char *oper() const {
    switch (m_type) {
    case Disjunction: return " || ";
    default: case Conjunction: return " && ";
    }
  }

  CompleteExpr *m_parent;
  std::ostream &m_final;
  std::stringstream m_out;
  bool m_first, m_tautology;
  ExprType m_type;
  int m_startIx, m_endIx;
};

class BranchTracker : public virtual InsnPatternVisitor {
protected:
  class branch {
  public:
    branch(int brNum) : m_startNum(brNum), m_nextNum(brNum + 1), m_maxNum(brNum + 1), m_altCount(0) { }

    int curBranchNum() const { return m_startNum; }
    int nextBranchNum() const { return m_nextNum; }
    int maxBranchNum() const { return m_maxNum; }
    void updateMaxNum(int nextNum) { if ( nextNum > m_maxNum) m_maxNum = nextNum; }

    void reset() { m_nextNum = m_startNum + 1; m_altCount++; }

    int curAltNum() const { return m_altCount; }

  private:
    int m_startNum, m_nextNum, m_maxNum, m_altCount;
  };
public:
  BranchTracker() : m_branchNum(0) { }

  virtual void newBranch() {
    m_branches.emplace_back(nextBranchNum());
  }

  virtual void endBranch() {
    auto nextNum(m_branches.back().maxBranchNum());
    m_branches.pop_back();

    if ( m_branches.empty() )
      m_branchNum = nextNum;
    else
      m_branches.back().updateMaxNum(nextNum);
  }

  virtual void newAlternative() {
    auto &br(m_branches.back());
    br.reset();
  }

  void endAllBranches() {
    while ( branchLevel() > 0 ) endBranch();
  }

protected:
  int curBranchNum() const {
    if ( m_branches.empty() ) return m_branchNum;
    else {
      return m_branches.back().curBranchNum();
    }
  }

  int nextBranchNum() const {
    if ( m_branches.empty() ) return m_branchNum;
    else return m_branches.back().nextBranchNum();
  }

  int curAltNum() const {
    if ( m_branches.empty() ) return 0;
    else return m_branches.back().curAltNum();
  }

  int branchLevel() const { return m_branches.size(); }

  const std::list<branch> &branches() const { return m_branches; }

private:
  int m_branchNum;
  std::list<branch> m_branches;
};

class CompleteGen : public virtual BranchTracker, public virtual InsnPatternVisitor {
public:
  CompleteGen(IndentedHeaderBase &h)
    : m_header(h), m_opNum(0) {
  }

  void finish() {
    endAllBranches();
    indent() << "return true;" << std::endl;
  }

  virtual void visit(const InsnPattern &p) {
    indent() << "if( !ops[" << m_opNum << "]";
    for ( const auto &branch: branches() )
      out() << " && branches[" << branch.curBranchNum() << "] == " << branch.curAltNum();
    out() << " ) return false;" << std::endl;

    m_opNum++;
    m_hasOps.back() = true;
  }

  virtual void newBranch() {
    BranchTracker::newBranch();
    m_hasOps.push_back(true);
    m_hasEmptyAlt.push_back(false);
  }

  virtual void endBranch() {
    checkEmptyAlt();

    m_hasOps.pop_back();
    auto hasEmptyAlt(m_hasEmptyAlt.back());
    m_hasEmptyAlt.pop_back();

    auto brNum(curBranchNum());
    BranchTracker::endBranch();

    if ( !hasEmptyAlt ) {
      indent() << "if ( branches[" << brNum << "] == 0";
      for ( const auto &br: branches() )
        out() << " && branches[" << br.curBranchNum() << "] == " << br.curAltNum();
      out() << ") return false;" << std::endl;
    }
  }

  virtual void newAlternative() {
    checkEmptyAlt();
    BranchTracker::newAlternative();

    m_hasOps.back() = false;
  }

private:
  void checkEmptyAlt() {
    if ( !m_hasOps.back() )
      m_hasEmptyAlt.back() = true;
  }

  std::ostream &indent(int extraNum = 0) const {
    return m_header.indent(branchLevel() + extraNum);
  }

  std::ostream &out() const {
    return m_header.noindent();
  }

  IndentedHeaderBase &m_header;
  int m_opNum;
  std::list<bool> m_hasOps, m_hasEmptyAlt;
};

class CanContinueGen : public virtual BranchTracker, public virtual InsnPatternVisitor {
public:
  CanContinueGen(IndentedHeaderBase &h)
    : m_header(h), m_opNum(0) {
  }

  virtual ~CanContinueGen() {
  }

  void finish() {
    endAllBranches();
    indent() << "return false;" << std::endl;
  }

  virtual void visit(const InsnPattern &p) {
    indent() << "if ( !ops[" << m_opNum << "] ) return true;" << std::endl;
    m_opNum++;
  }

  virtual void newBranch() {
    indent() << "if ( branches[" << curBranchNum() << "] == 0 ) return true;" << std::endl;
    BranchTracker::newBranch();
  }

  virtual void newAlternative() {
    auto altNum(curAltNum());
    BranchTracker::newAlternative();
    if ( altNum > 0 ) indent(-1) << "}" << std::endl;
    indent(-1) << "if ( branches[" << curBranchNum() << "] == " << curAltNum() << " ) {" << std::endl;
  }

  virtual void endBranch() {
    auto altNum(curAltNum());
    BranchTracker::endBranch();
    if ( altNum > 0 ) indent() << "}" << std::endl;
  }

private:
  std::ostream &indent(int extra = 0) {
    return m_header.indent(branchLevel() + extra);
  }

  IndentedHeaderBase &m_header;
  int m_opNum;
};

class SettersOutputter : public InsnVarType::SettersVisitor {
public:
  SettersOutputter(const std::string &baseNm, IndentedHeaderBase &b)
    : m_header(b), m_baseName(baseNm) {
    m_args.insert(std::make_pair("member", "m_" + cName(baseNm)));
    m_args.insert(std::make_pair("new", "var"));
  }

  virtual ~SettersOutputter() {
  }

  virtual void setter(const std::string &nm, const template_string &v) {
    m_header.noindent() << " else if ( nm == \"" << m_baseName << "." << nm << "\" ) {" << std::endl;
    m_header.noindent() << v.render(m_args);
    m_header.indent(-1) << "}";
  }

private:
  IndentedHeaderBase &m_header;
  const std::string &m_baseName;
  std::map<std::string, std::string> m_args;
};

class ConsumedOperationsGen : public OpMarker {
public:
  ConsumedOperationsGen(const std::string &nm, const IndentedHeaderBase &out)
    : m_name(nm), m_out(out), m_index(0) {
  }
  virtual ~ConsumedOperationsGen() { }

  inline const IndentedHeaderBase &out() const { return m_out; }

  virtual void mark() override {
    out().indent() << "if ( ops[" << m_index << "] ) " << m_name << ".matchOp(ops[" << m_index << "]);" << std::endl;
    m_index++;
  }

  virtual void skip() override {
    m_index++;
  }

private:
  std::string m_name;
  const IndentedHeaderBase &m_out;

  int m_index;
};

FilesystemGenerator::FilesystemGenerator(const std::filesystem::path &base)
  : m_base(base) {
}

FilesystemGenerator::~FilesystemGenerator() {
}

void FilesystemGenerator::generate(const std::filesystem::path &outPath,
                                   std::function<void(const std::filesystem::path &)> generator) {
  std::error_code ec;
  std::filesystem::path output(m_base / outPath);

  if ( std::filesystem::create_directories(output.parent_path(), ec) ) {
    std::cerr << "Creating output directory " << output.parent_path() << std::endl;
  }

  if ( ec ) {
    std::cerr << "Error creating " << output.parent_path() << ": " << ec << std::endl;
  }
  std::cerr << "Generating " << output << std::endl;
  generator(output);
}

DepsDumper::DepsDumper(const ArchDescBuilder &b,
                       const std::filesystem::path &relPath,
                       std::ostream &out)
  : m_builder(b), m_out(out), m_relative(relPath) {
}

DepsDumper::~DepsDumper() {
}

void DepsDumper::generate(const std::filesystem::path &outPath,
                          std::function<void(const std::filesystem::path &)> generator) {
  m_out << (m_relative / outPath).native() << ": ";
  std::transform(m_builder.lexers().begin(),
                 m_builder.lexers().end(), std::ostream_iterator<std::string>(m_out, " "),
                 [](const auto &lexer) {
                   return lexer.second->filename();
                 });
  m_out << std::endl;
}

ArchDescBuilder::ArchDescBuilder() {
}

void ArchDescBuilder::param(const std::string &name, Literal &value) {
  if ( name == "architecture" ) {
    std::string nm;
    SetStringLiteral set(nm, WarnMissing("architecture", "string"));
    value.visit(set);
    m_name = nm;
  } else if ( name == "defaultCallingConvention" ) {
    SetStringLiteral set(m_defCallConv, WarnMissing("architecture", "string"));
    value.visit(set);
  } else if ( name == "opcodeBuilder" ) {
    SetStringLiteral set(m_opcodeBuilder, WarnMissing("opcodeBuilder", "string"));
    value.visit(set);
  } else if ( name == "defaultEncoder" ) {
    SetStringLiteral set(m_defaultInsnEncoder, WarnMissing("defaultEncoder", "string"));
    value.visit(set);
  } else
    std::cerr << "Parameter " << name << " not valid for arch desc" << std::endl;
}

void ArchDescBuilder::setArchitecture(const std::string &name) {
  if ( m_name ) {
    std::cerr << "TODO name given twice" << std::endl;
  }

  m_name = name;
}

void ArchDescBuilder::includeFile(const std::string &fromFile, const std::string &filename) {
  std::filesystem::path path(fromFile);
  path = path.parent_path();

  std::filesystem::path includedPath(filename);

  path /= includedPath;
  includeFile(path);
}

void ArchDescBuilder::includeFile(const std::filesystem::path &filename) {
  std::fstream in(filename.native(), std::fstream::in);
  std::stringstream error;
  error << "While parsing the file " << filename;

  NncErrorLocation l(error.str());

  std::unique_ptr<ArchDescLexer> lexer(makeLexer(filename, in));
  nnc::parser parser(*lexer, *this);
  m_lexers.insert({filename, std::move(lexer)});

  parser();
}

void ArchDescBuilder::addCHeader(const std::string &chunk) {
  m_cheaders.push_back(chunk);
}

void ArchDescBuilder::addInsnRule(InsnRule *r) {
  m_rules.emplace_back(r);
}

void ArchDescBuilder::addInsn(Insn *i) {
  m_insns.emplace_back(i);
}

RegisterFactory &ArchDescBuilder::getRegister(const std::string &nm) {
  auto it(m_registers.find(nm));

  if ( it == m_registers.end() ) {
    RegisterBase reg;
    auto res(m_registers.emplace(nm, std::make_unique<RegisterFactory>()));
    it = res.first;
  }

  return *it->second;
}

void ArchDescBuilder::addRegisterClass(RegClass *rc) {
  std::unique_ptr<RegClass> uniq(rc);
  rc->ensureRegisters(*this);
  m_regClass[uniq->name()] = std::move(uniq);
}

void ArchDescBuilder::generate(const std::filesystem::path &base) {
  std::filesystem::path output(base);
  output /= std::filesystem::path("arch") / cArchName();

  FilesystemGenerator fs(output);

  generate(fs);
}

void ArchDescBuilder::generate(GenerateVisitor &v) {
  // Generate headers
  v.generate("schedule.hpp", std::bind(&ArchDescBuilder::generateScheduleHeader, this, std::placeholders::_1));
  v.generate("insns.hpp", std::bind(&ArchDescBuilder::generateInsnsHeader, this, std::placeholders::_1));
  v.generate("rules.cpp", std::bind(&ArchDescBuilder::generateRuleImpl, this, std::placeholders::_1));
  v.generate("insns.cpp", std::bind(&ArchDescBuilder::generateInsnsImpl, this, std::placeholders::_1));

  v.generate("registers.hpp", std::bind(&ArchDescBuilder::generateRegistersHeader, this, std::placeholders::_1));
  v.generate("registers.cpp", std::bind(&ArchDescBuilder::generateRegistersImpl, this, std::placeholders::_1));
}

void ArchDescBuilder::generateRegistersHeader(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardHeader h(out, *this, "registers");

  h.noindent() << "#include \"compile/regalloc.hpp\"" << std::endl;
  h.noindent() << "#include \"compile/registers.hpp\"" << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());

  h.indent() << "class RegisterFile : public virtual ::nnc::compile::RegisterFile {" << std::endl;
  h.indent() << "public:" << std::endl;
  h.indent(1) << "RegisterFile();" << std::endl;
  h.indent(1) << "virtual ~RegisterFile();" << std::endl << std::endl;
  h.indent(1) << "virtual ::nnc::compile::Register lookupRegister(const std::string &name) const;" << std::endl << std::endl;
  h.indent(1) << "virtual const char *registerName(int ix) const;" << std::endl;
  h.indent(1) << "virtual const char *regclassName(int ix) const;" << std::endl;
  h.indent(1) << "virtual int regclassCount() const;" << std::endl;
  h.indent(1) << "virtual bool registerInClass(int regIx, int regClass) const;" << std::endl << std::endl;
  h.indent(1) << "virtual int registerCount() const;" << std::endl << std::endl;

  int regIx(0);
  for ( const auto &reg: m_registers ) {
    h.indent(1) << "::nnc::compile::Register " << cName(reg.first) << "() const;" << std::endl;
    regIx++;
  }

  h.indent() << "protected:" << std::endl;
  h.indent(1) << "virtual const char *registerFileName() const;" << std::endl;
  h.indent() << "private:" << std::endl;
  h.indent() << "};" << std::endl;

  h.noindent() << "#ifndef REG_IMPL" << std::endl;
  h.indent()   << "extern RegisterFile registers;" << std::endl;
  h.noindent() << "#endif" << std::endl;

  h.pushNamespace("regclass");

  for ( const auto &cls: m_regClass ) {
    auto clsName(cName(cls.first));
    h.indent() << "class " << clsName << "_class : public ::nnc::compile::RegClass {" << std::endl;
    h.indent() << "public:" << std::endl;
    h.indent(1) << "virtual ~" << clsName << "_class();" << std::endl;
    h.indent(1) << "virtual int index() const override;" << std::endl;
    h.indent(1) << "virtual const char *name() const override;" << std::endl;
    h.indent(1) << "virtual const char *desc() const override;" << std::endl;
    h.indent(1) << "virtual RegisterFile &registers() const override;" << std::endl;
    h.indent(1) << "virtual void visitRegisters(::nnc::compile::RegClassMembers &decl) const override;" << std::endl;
    h.indent() << "};" << std::endl << std::endl;
    h.noindent() << "#ifndef REG_IMPL" << std::endl;
    h.indent() << "extern " << clsName << "_class " << clsName << ";" << std::endl;
    h.noindent() << "#endif" << std::endl << std::endl;
  }
}

void ArchDescBuilder::generateRegistersImpl(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardImpl h(out);

  h.noindent() << "#define REG_IMPL" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/registers.hpp\"" << std::endl;

  h.noindent() << "using namespace ::nnc::compile;";

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());

  h.indent() << "RegisterFile registers;" << std::endl << std::endl;

  h.indent() << "RegisterFile::RegisterFile() { }" << std::endl;
  h.noindent() << std::endl;

  h.indent() << "RegisterFile::~RegisterFile() { }" << std::endl;
  h.noindent() << std::endl;

  for ( auto [it, i ] = std::tuple { m_registers.begin(), 0 };
        it != m_registers.end();
        it++, i++ ) {
    h.indent() << "::nnc::compile::Register RegisterFile::" << cName(it->first) << "() const {" << std::endl;
    h.indent(1) << "return Register(&registers, " << i << ");" << std::endl;
    h.indent() << "}" << std::endl;
  }

  h.indent() << "Register RegisterFile::lookupRegister(const std::string &name) const {" << std::endl;
  for ( auto [it, i] = std::tuple { m_registers.begin(), 0 };
        it != m_registers.end();
        it++, i++ ) {
    if ( it != m_registers.begin() )
      h.indent(1) << "else ";
    else
      h.indent(1);
    h.noindent() << "if ( name == \"" << it->first << "\" ) return Register(this, " << i << ");" << std::endl;
  }
  h.noindent() << std::endl;
  h.indent(1) << "throw ::nnc::exception::RegisterDoesNotExist(this, name);" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "const char *RegisterFile::registerName(int ix) const {" << std::endl;
  h.indent(1) << "switch ( ix ) {" << std::endl;
  for ( auto [ it, i ] = std::tuple { m_registers.begin(), 0 };
        it != m_registers.end();
        it++, i++ ) {
    h.indent(1) << "case " << i << ": return \"" << it->first << "\";" << std::endl;
  }
  h.indent(1) << "default:" << std::endl;
  h.indent(2) << "throw ::nnc::exception::RegisterIndexOutOfRange(ix, registerCount());" << std::endl;
  h.indent(1) << "}" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "const char *RegisterFile::regclassName(int ix) const {" << std::endl;
  h.indent(1) << "switch ( ix ) {" << std::endl;
  for ( auto [it, i] = std::tuple { m_regClass.begin(), 0 };
        it != m_regClass.end();
        it++, i++ ) {
    h.indent(1) << "case " << i << ": return \"" << it->first << "\";" << std::endl;
  }
  h.indent(1) << "default:" << std::endl;
  h.indent(2) << "throw ::nnc::exception::RegisterIndexOutOfRange(ix, regclassCount());" << std::endl;
  h.indent(1) << "}" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "int RegisterFile::regclassCount() const {" << std::endl;
  h.indent(1) << "return " << m_regClass.size() << ";" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "bool RegisterFile::registerInClass(int regIx, int regClass) const {" << std::endl;
  h.indent(1) << "switch ( regClass ) {" << std::endl;
  for ( auto [clsIt, clsIx] = std::tuple { m_regClass.begin(), 0 };
        clsIt != m_regClass.end();
        clsIt++, clsIx++ ) {
    h.indent(1) << "case " << clsIx << ":" << std::endl;
    h.indent(2) << "switch ( regIx ) {" << std::endl;
    for ( const auto &regNm: *clsIt->second ) {
      getRegister(regNm);
      auto regIt(m_registers.find(regNm));
      int regIx(std::distance(m_registers.begin(), regIt));
      h.indent(2) << "case " << regIx << ": return true;" << std::endl;
    }
    h.indent(2) << "default: return false;" << std::endl;
    h.indent(2) << "}" << std::endl;
  }
  h.indent(1) << "default: return false;" << std::endl;
  h.indent(1) << "}" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "int RegisterFile::registerCount() const {" << std::endl;
  h.indent(1) << "return " << m_registers.size() << ";" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "const char *RegisterFile::registerFileName() const {" << std::endl;
  h.indent(1) << "return \"" << *m_name << "\";" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.pushNamespace("regclass");

  int clsIx(0);
  for ( const auto &cls: m_regClass ) {
    auto clsName(cName(cls.first));
    h.indent() << clsName << "_class " << clsName << ";" << std::endl << std::endl;
    h.indent() << clsName << "_class::~" << clsName << "_class() { }" << std::endl << std::endl;
    h.indent() << "const char *" << clsName << "_class::name() const { return \"" << cls.first << "\"; }" << std::endl << std::endl;
    h.indent() << "int " << clsName << "_class::index() const { return " << clsIx << "; }" << std::endl << std::endl;
    h.indent() << "const char *" << clsName << "_class::desc() const { return \"" << cls.second->doc() << "\"; }" << std::endl << std::endl;
    h.indent() << "RegisterFile &" << clsName << "_class::registers() const { return ::nnc::arch::" << cArchName() << "::registers; }" << std::endl;
    h.indent() << "void " << clsName << "_class::visitRegisters(::nnc::compile::RegClassMembers &decl) const {" << std::endl;
    for ( const auto &reg: *cls.second ) {
      h.indent(1) << "decl.reg(::nnc::arch::" << cArchName() << "::registers.lookupRegister(\"" << reg << "\"));" << std::endl;
    }
    h.indent() << "}" << std::endl;

    clsIx++;
  }
}

void ArchDescBuilder::generateInsnsImpl(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardImpl h(out);

  h.noindent() << "#include \"arch/" << cArchName() << "/insns.hpp\"" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/registers.hpp\"" << std::endl;
  h.noindent() << "#include \"exception.hpp\"" << std::endl;
  h.noindent() << "#include \"compile/rtl_ops.hpp\"" << std::endl;
  h.noindent() << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("insn");

  for ( const auto &insn : m_insns ) {
    std::string clsNm(cName(insn->name()));
    h.indent() << clsNm << "::";
    insn->declareConstructor(clsNm, h.noindent()) << std::endl;

    std::map<std::string, std::string> vars;

    h.indent(1) << ": ::nnc::compile::RtlOp(\"" << insn->name() << "\")" << std::endl;
    for ( const auto &arg : insn->args() ) {
      h.indent(1) << ", " << "m_" << cName(arg.name(), false) << "(" << cName(arg.name()) << ")" << std::endl;
      vars[arg.name()] = "m_" + cName(arg.name(), false);
    }
    h.indent() << "{" << std::endl;
    for ( const auto &arg: insn->args() ) {
      if ( arg.type().isDefaultable() && arg.optional() ) {
        IndentedHeader lines(h, 1);
        arg.type().outputArgMakeDefault("_fn", "m_" + cName(arg.name()), cName(arg.name()), lines);
        lines.noindent() << std::endl;
      }
    }
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declDestructor(clsNm) << " {" << std::endl;
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declMember("void", clsNm, "operands").arg("::nnc::compile::RtlOperandVisitor &v")._const() << "{" << std::endl;
    for ( const auto &arg : insn->args() ) {
      arg.type().outputVisitOperand("v", arg.name(), "m_" + cName(arg.name()), arg.direction(),
                                    h.indent(1));
    }
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declMember("void", clsNm, "regclasses").arg("::nnc::compile::RegClassDeclarer &decl")._const() << "{" << std::endl;
    for ( const auto &arg: insn->args() ) {
      if ( arg.type().hasRegClass() ) {
        arg.type().outputRegClasses("decl", arg.name(), "m_" + cName(arg.name()), h.indent(1));
      }
    }
    for ( const auto &i: insn->intersects() ) {
      InsnArgDecl &d(insn->arg(i.a()));
      bool hasCond(i.hasCondition());
      int intersectIndent(1);

      if ( hasCond ) {
        h.indent(1) << "if ( " << i.condition().render(vars) << " ) {" << std::endl;;
        intersectIndent = 2;
      }
      d.type().outputIntersect("decl", "m_" + cName(i.a()), "m_" + cName(i.b()),
                               i.regclass(), h.indent(intersectIndent));
      if ( hasCond )
        h.indent(1) << "}" << std::endl;
    }
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declMember("void", clsNm, "operand").arg("const std::string &nm").arg("std::shared_ptr<::nnc::compile::RtlVariable> var") << "{" << std::endl;

    bool first_setter(true);
    for ( const auto &arg : insn->args() ) {
      if ( !first_setter ) {
        h.noindent() << " else ";
      } else {
        first_setter = false;
        h.indent(1);
      }

      h.noindent() << "if (nm == \"" << arg.name() << "\") {" << std::endl;
      h.indent(2) << "m_" << cName(arg.name(), false) << " = var;" << std::endl;
      h.indent(1) << "}";

      // Check if the args ctype has any setters defined
      IndentedHeader ch(h, 1);
      SettersOutputter setters(arg.name(), ch);
      arg.type().setters(setters);
    }

    if ( first_setter ) h.indent(1);
    else {
      h.noindent() << " else" << std::endl;
      h.indent(2);
    }

    h.noindent() << "throw exception::RtlOpArgDoesNotExist(nm);" << std::endl;
    h.indent() << "}" << std::endl << std::endl;

    h.indent() << declMember("std::uint64_t", clsNm, "cost")._const() << "{ return " << insn->cost() << "; }" << std::endl << std::endl;

    h.indent() << declMember("std::ostream &", clsNm, "encode").arg("const ::nnc::compile::RtlRegisterMapper &inputs").arg("const ::nnc::compile::RtlRegisterMapper &outputs").arg("std::ostream &out")._const() << "{" << std::endl;
    if ( insn->hasCustomEmit() ) {
      std::map<std::string, std::string> varNms;
      for ( const auto &var : insn->args() ) {
        std::stringstream ref;

        ref << "(this->m_" << cName(var.name()) << ")";

        varNms.emplace(var.name(), ref.str());
      }
      h.indent(1) << insn->customEmit().render(varNms) << std::endl;
    } else {
      h.indent(1) << m_opcodeBuilder << "(inputs, outputs, out)." << clsNm << "(";
      bool first(true);
      for ( const auto &arg: insn->args() ) {
        if ( !first ) h.noindent() << ", ";
        h.noindent() << "m_" << cName(arg.name());
        first = false;
      }
      h.noindent() << ");" << std::endl;
    }
    h.indent(1) << "return out;" << std::endl;
    h.indent() << "}" << std::endl;
  }
}

void ArchDescBuilder::generateApply(InsnRule &rule, const IndentedHeaderBase &h) {
  std::set<std::string> m_handled;

  h.indent() << "::nnc::compile::RtlFunction &fn(sel.function());" << std::endl;

  MnemonicsCollector c;
  rule.pats().declMnemonicInterest(c);

  bool first(true);
  for ( const auto &mn: c ) {
    (first ? h.indent() : (h.noindent() << " else "))
      << "if ( strcmp(op.mnemonic(), \"" << mn << "\") == 0 ) {" << std::endl;

    MnemonicApplyGen gen(mn, rule, h);
    rule.pats().visitPatterns(gen);

    h.indent() << "}";

    first = false;
  }

  h.noindent() << std::endl;
}

void ArchDescBuilder::generateRuleMatchers(InsnRule &rule, IndentedHeaderBase &hdr) {
  RuleMatcherGen gen(rule, hdr);
  rule.pats().visitPatterns(gen);
}

void ArchDescBuilder::generateScheduleHeader(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardHeader h(out, *this, "schedule");
  h.indent() << "#include \"compile/genericschedule.hpp\"" << std::endl;
  h.indent() << "#include \"compile/registers.hpp\"" << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("schedule");

  std::string scheduleClsNm("block_scheduler");

  h.indent() << "class " << scheduleClsNm << " : public ::nnc::compile::GenericScheduler {" << std::endl;
  h.indent() << "public:" << std::endl;
  h.indent(1) << scheduleClsNm << "(::nnc::compile::GenericFunctionScheduler &dst, std::shared_ptr<::nnc::compile::RtlBasicBlock> b);" << std::endl;
  h.indent(1) << "virtual ~" << scheduleClsNm << "();" << std::endl << std::endl;
  h.indent() << "protected:" << std::endl;
  h.indent(1) << "virtual void buildPatterns(::nnc::compile::InsnSelector &sel);" << std::endl;
  h.indent() << "};" << std::endl << std::endl;

  std::string fnScheduleClsNm("scheduler");
  h.indent() << "class " << fnScheduleClsNm << " : public ::nnc::compile::GenericFunctionScheduler {" << std::endl;
  h.indent() << "public:" << std::endl;
  h.indent(1) << fnScheduleClsNm << "(::nnc::compile::RtlFunction &src);" << std::endl;
  h.indent(1) << "virtual ~" << fnScheduleClsNm << "();" << std::endl << std::endl;
  h.indent(1) << "virtual ::nnc::compile::RegisterFile &registers() const override;" << std::endl << std::endl;
  h.indent() << "protected:" << std::endl;
  h.indent(1) << "virtual std::unique_ptr<::nnc::compile::GenericScheduler> makeBlockScheduler(std::shared_ptr<::nnc::compile::RtlBasicBlock> block);" << std::endl;
  h.indent(1) << "virtual std::unique_ptr<::nnc::compile::CallingConvention> defaultCallingConvention() const;" << std::endl;
  h.indent(1) << "virtual const ::nnc::compile::InsnEncoder &defaultInsnEncoder() const;" << std::endl;
  h.indent(1) << m_defaultInsnEncoder << " m_encoder;" << std::endl;
  h.indent() << "};" << std::endl;
}


void ArchDescBuilder::generateInsnsHeader(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardHeader h(out, *this, "insns");
  h.indent() << "#include \"compile/rtl.hpp\"" << std::endl;
  h.indent() << "#include \"compile/rtl_ops_base.hpp\"" << std::endl;
  h.indent() << "#include \"compile/encoding.hpp\"" << std::endl;
  h.indent() << "#include \"compile/regalloc.hpp\"" << std::endl;

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("insn");

  for ( const auto &insn : m_insns ) {
    h.indent() << "class " << cName(insn->name()) << " : public ::nnc::compile::RtlOp, public ::nnc::compile::RtlRegisterOp, public ::nnc::compile::RtlEmitOp, public ::nnc::compile::RtlCostedOp {" << std::endl;
    h.indent() << "public:" << std::endl;
    insn->declareConstructor(cName(insn->name()), h.indent(1), true) << ";" << std::endl;
    h.indent(1) << "virtual ~" << cName(insn->name()) << "();" << std::endl;

    h.noindent() << std::endl;
    // RtlOp functions
    h.indent(1) << "virtual void operands(::nnc::compile::RtlOperandVisitor &v) const;" << std::endl;
    h.indent(1) << "virtual void operand(const std::string &nm, std::shared_ptr<::nnc::compile::RtlVariable> var);" << std::endl;
    h.indent(1) << "virtual void regclasses(::nnc::compile::RegClassDeclarer &decl) const;" << std::endl;
    h.indent(1) << "virtual std::ostream &encode(const ::nnc::compile::RtlRegisterMapper &inputs, const ::nnc::compile::RtlRegisterMapper &outputs, std::ostream &out) const override;" << std::endl;
    h.indent(1) << "virtual std::uint64_t cost() const override;" << std::endl;

    h.noindent() << std::endl;

    h.indent() << "private:" << std::endl;
    for ( const auto &arg : insn->args() ) {
      std::ostream &line(h.indent(1));
      arg.type().outputCType(line) << " m_" << cName(arg.name(), false) << ";" << std::endl;
    }
    h.indent() << "};" << std::endl;
  }

}

void ArchDescBuilder::generateRuleImpl(const std::filesystem::path &outPath) {
  std::fstream out(outPath.native(), std::fstream::out);
  if ( out.bad() ) {
    std::cerr << "Could not generate " << outPath << std::endl;
    return;
  }

  StandardImpl h(out);

  h.noindent() << "#include \"compile/insnsel.hpp\"" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/schedule.hpp\"" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/registers.hpp\"" << std::endl;
  h.noindent() << "#include \"arch/" << cArchName() << "/insns.hpp\"" << std::endl;
  h.noindent() << std::endl;
  h.noindent() << "#include <algorithm>" << std::endl;
  h.noindent() << "#include <functional>" << std::endl;
  h.noindent() << "#include <memory>" << std::endl;
  h.noindent() << "#include <span>" << std::endl;
  h.noindent() << "#include <cstring>" << std::endl;
  h.noindent() << "#include <string>" << std::endl;

  codeSection(h.noindent(), "rules_preamble");

  h.pushNamespace("nnc");
  h.pushNamespace("arch");
  h.pushNamespace(cArchName());
  h.pushNamespace("rules");

  codeSection(h.noindent(), "rules_preamble_namespaced");

  for ( const auto &rule : m_rules ) {
    generateRuleMatchers(*rule, h);
    std::map<std::string, std::string> varNms;
    for ( const auto &var : rule->vars() ) {
      std::stringstream ref;

      ref << "(this->var_" << cName(var.first) << ")";

      varNms.emplace(var.first, ref.str());
    }

    MnemonicsCollector mnemonics;
    rule->pats().visitPatterns(mnemonics);

    h.indent() << "class " << cName(rule->name()) << " : public virtual ::nnc::compile::InsnSelRule, public virtual ::nnc::compile::SelectedInsn {" << std::endl;
    h.indent() << "public:" << std::endl;

    // Default constructor
    h.indent(1) << cName(rule->name()) << "()" << std::endl;
    bool first(true);
    for ( const auto &var : rule->vars() ) {
      if ( var.second.type() != InsnVariable::ConstantType ) {
        h.indent(1) << (first ? ": " : ", ") << "var_" << cName(var.first) << "(nullptr)" << std::endl;
        first = false;
      }
    }
    h.indent(1) << "{" << std::endl;
    h.indent(2) << "std::fill(std::begin(ops), std::end(ops), nullptr);" << std::endl;
    if ( mnemonics.hasBranches() )
      h.indent(2) << "std::fill(std::begin(branches), std::end(branches), 0);" << std::endl;
    h.indent(1) << "}" << std::endl;

    // Copy constructor
    h.indent(1) << cName(rule->name()) << "(const " << cName(rule->name()) << "& o) =default;" << std::endl;

    h.indent(1) << "virtual ~" << cName(rule->name()) << "() { }" << std::endl << std::endl;

    // InsnSelRule
    h.indent(1) << "virtual void apply(::nnc::compile::InsnSelector &sel, ::nnc::compile::RtlOp &op) const {" << std::endl;
    generateApply(*rule, IndentedHeader(h, 2));
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "virtual void registerInterest(::nnc::compile::InterestRecorder &r) const {" << std::endl;
    for ( const std::string &mnemonic : mnemonics ) {
      h.indent(2) << "r.instruction(\"" << mnemonic << "\");" << std::endl;
    }
    h.indent(1) << "}" << std::endl << std::endl;

    // SelectedInsn
    h.indent(1) << "virtual void consumedOperations(::nnc::compile::RtlOpMarker &marker) const {" << std::endl;
    ConsumedOperationsGen consumedOps("marker", IndentedHeader(h, 2));
    rule->pats().markOps(consumedOps);
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "virtual void build(::nnc::compile::RtlOpSelector &compiled) const {" << std::endl;
    for ( const auto &g : rule->generated() ) {
      if ( g.isTemplate() ) {
        auto genNms(varNms);
        genNms.emplace("fn", "(compiled.function())");
        genNms.emplace("builder", "compiled");
        h.indent(2) << g.literal().render(genNms) << std::endl;
      } else {
        auto &insn(lookupInsn(g.mnemonic(), g.errorContext()));
        if ( g.hasConds() ) {
          h.indent(2) << "if (";
          bool first(true);
          for ( const auto &cond: g.conds() ) {
            if ( !first ) h.noindent() << " && ";
            h.noindent() << cond.render(varNms);
            first = false;
          }
          h.noindent() << ")";
        } else
          h.indent(2);
        h.noindent() << "compiled.emplace_op<" << cInsnName(g.mnemonic()) << ">(compiled.function()";
        std::set<std::string> argsReceived;
        auto sig(insn.args().begin());
        std::vector<std::optional<std::string>> args(insn.args().size());
        auto out(args.begin());

        for ( auto arg(g.args().begin());
              arg != g.args().end();
              ++arg, ++sig, ++out ) {
          if ( sig == insn.args().end() )
            throw NncGenerationError(g.errorContext(), "Arity mismatch in call to " + g.mnemonic());

          std::stringstream argStr;
          argStr << arg->render(varNms);
          *out = argStr.str();
          argsReceived.insert(sig->name());
        }

        // Now apply named arguments
        for ( const auto &namedArg : g.namedArgs() ) {
          // If we've already passed this arg error
          if ( argsReceived.find(namedArg.first) != argsReceived.end() ) {
            throw NncGenerationError(g.errorContext(), "Argument " + namedArg.first + " already passed to " + g.mnemonic());
          }

          // Make sure this argument exists
          auto argSig(std::find_if(sig, insn.args().end(), [&namedArg](const auto &argsig) { return argsig.name() == namedArg.first; }));
          if ( argSig == insn.args().end() ) {
            throw NncGenerationError(g.errorContext(), "Named argument " + namedArg.first + " does not exist in " + g.mnemonic());
          }

          std::stringstream argStr;
          argStr << namedArg.second.render(varNms);
          *(out + std::distance(sig, argSig)) = argStr.str();
          argsReceived.insert(namedArg.first);
        }

        // Make sure all required args were inserted
        for ( const auto &arg: insn.args() ) {
          if ( !arg.optional() && argsReceived.find(arg.name()) == argsReceived.end() )
            throw NncGenerationError(g.errorContext(), "Insn call " + g.mnemonic() + " called without arg " + arg.name());
        }

        auto lastArg(std::find_if(std::make_reverse_iterator(args.end()), std::make_reverse_iterator(args.begin()),
                                  [](const auto &arg) { return arg.has_value(); }));
        args.erase(lastArg.base(), args.end());

        sig = insn.args().begin();
        for ( decltype(args)::iterator arg(args.begin());
              arg != args.end();
              ++ arg, ++sig ) {
          if ( arg->has_value() ) {
            h.noindent() << ", " << **arg;
          } else if ( sig->optional() ) {
            h.noindent() << ", ";
            if ( sig->type().isDefaultable() )
              sig->type().outputArgDefault(h.noindent());
            else
              throw NncGenerationError(g.errorContext(), "Argument " + sig->name() + " is optional, but not defaultable");
          } else {
            throw NncGenerationError(g.errorContext(), "Insn call " + g.mnemonic() + " called without required arg " + sig->name());
          }
        }

        h.noindent() << ");" << std::endl;
      }
    }

    // Now alias any variables
    for ( const auto &alias: rule->aliases() ) {
      h.indent(2) << "compiled.alias(var_" << cName(alias.first) << ", var_" << cName(alias.second) << ");" << std::endl;
    }

    h.indent(1) << "}" << std::endl << std::endl;


    h.indent() << "private:" << std::endl;
    h.indent(1) << "bool complete() const {" << std::endl;

    {
      IndentedHeader ch(h, 2);
      CompleteGen g(ch);
      rule->pats().visitPatterns(g);
      g.finish();
    }

//    h.indent(2) << "return std::all_of(std::begin(ops), std::end(ops), [](::nnc::compile::RtlOp *p) { return !!p; });" << std::endl;
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "bool canContinue() const {" << std::endl;
    {
      IndentedHeader ch(h, 2);
      CanContinueGen g(ch);
      rule->pats().visitPatterns(g);
      g.finish();
    }
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "bool check(::nnc::compile::RtlFunction &fn) {" << std::endl;
    for ( const auto &cond : rule->conds() ) {
      h.indent(2) << "if ( !(" << cond.render(varNms) << ")) {" << std::endl;
      h.indent(3) << "return false;" << std::endl;
      h.indent(2) << "}" << std::endl;
    }
    h.indent(2) << "return true;" << std::endl;
    h.indent(1) << "}" << std::endl << std::endl;

    h.indent(1) << "std::array<::nnc::compile::RtlOp *, " << mnemonics.patternCount() << "> ops;" << std::endl;
    if ( mnemonics.hasBranches() )
      h.indent(1) << "std::array<int, " << mnemonics.branchCount() << "> branches;" << std::endl;

    for ( const auto &var : rule->vars() ) {
      declVar(var.first, var.second.type(), IndentedHeader(h, 1));
    }

    rule->extraPrivate().render(varNms).emit_by_lines(IndentedHeader(h, 1));

    h.indent() << "};" << std::endl;
  }

  h.popNamespace();
  h.pushNamespace("schedule");

  std::string scheduleClsNm("block_scheduler");
  h.indent() << scheduleClsNm << "::" << scheduleClsNm << "(::nnc::compile::GenericFunctionScheduler &dst, std::shared_ptr<::nnc::compile::RtlBasicBlock> b)" << std::endl;
  h.indent(1) << ": ::nnc::compile::GenericScheduler(dst, b) {" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << scheduleClsNm << "::~" << scheduleClsNm << "() {" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << "void " << scheduleClsNm << "::buildPatterns(::nnc::compile::InsnSelector &sel) {" << std::endl;
  for ( const auto &rule: m_rules ) {
    h.indent(1) << "sel.addRule(std::make_unique<rules::" << cName(rule->name()) << ">());" << std::endl;
  }
  h.indent() << "}" << std::endl;

  std::string fnScheduleClsNm("scheduler");
  h.indent() << fnScheduleClsNm << "::" << fnScheduleClsNm << "(::nnc::compile::RtlFunction &src)" << std::endl;
  h.indent(1) << ": ::nnc::compile::GenericFunctionScheduler(src)" << std::endl;
  h.indent() << "{" << std::endl;
  h.indent() << "}" << std::endl << std::endl;;

  h.indent() << declDestructor(fnScheduleClsNm) << std::endl;
  h.indent() << "{" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() <<
    declMember("std::unique_ptr<::nnc::compile::GenericScheduler>", fnScheduleClsNm, "makeBlockScheduler")
    .arg("std::shared_ptr<::nnc::compile::RtlBasicBlock> block") << std::endl;
  h.indent() << "{" << std::endl;
  h.indent(1) << scheduleClsNm << " *scheduler(new " << scheduleClsNm << "(*this, block));" << std::endl;
  h.indent(1) << "return std::unique_ptr<::nnc::compile::GenericScheduler>(static_cast<::nnc::compile::GenericScheduler *>(scheduler));" << std::endl;
  h.indent() << "}" << std::endl << std::endl;

  h.indent() << declMember("std::unique_ptr<::nnc::compile::CallingConvention>", fnScheduleClsNm, "defaultCallingConvention")._const() << std::endl;
  h.indent() << "{" << std::endl;
  h.indent(1) << "return std::make_unique<" << m_defCallConv << ">();" << std::endl;
  h.indent() << "}" << std::endl;

  h.indent() << declMember("const ::nnc::compile::InsnEncoder &", fnScheduleClsNm, "defaultInsnEncoder")._const() << std::endl;
  h.indent() << "{" << std::endl;
  h.indent(1) << "return m_encoder;" << std::endl;
  h.indent() << "}" << std::endl;

  h.indent() << declMember("::nnc::compile::RegisterFile &", fnScheduleClsNm, "registers")._const() << std::endl;
  h.indent() << "{" << std::endl;
  h.indent(1) << "return ::nnc::arch::" << cArchName() << "::registers;" << std::endl;
  h.indent() << "}" << std::endl;

  codeSection(h.noindent(), "rules_postamble_namespaced");
}

void ArchDescBuilder::addCType(const std::string &name, CType *c) {
  m_cTypes.insert(std::make_pair(name, std::unique_ptr<CType>(c)));
}

CType &ArchDescBuilder::cType(const std::string &nm) {
  auto it(m_cTypes.find(nm));
  if ( it == m_cTypes.end() )
    throw NncParseError("C type " + nm + " not found");

  return *it->second;
}

void ArchDescBuilder::addCodeSection(const std::string &sectionName, const std::string &contents) {
  m_codeSections.insert(std::make_pair(sectionName, contents));
}

void ArchDescBuilder::codeSection(std::ostream &out, const std::string &sectionName) {
  auto r(m_codeSections.equal_range(sectionName));
  std::transform(r.first, r.second, std::ostream_iterator<std::string>(out, "\n"), [](const auto &k) { return k.second; });
}

Insn &ArchDescBuilder::lookupInsn(const std::string &nm, const NncErrorContextStack &fromWhere) {
  auto found(std::find_if(m_insns.begin(), m_insns.end(), [&nm] (const auto &insn) { return insn->name() == nm; }));
  if ( found == m_insns.end() )
    throw NncGenerationError(fromWhere, "Could not find instruction " + nm);

  return **found;
}

void declVar(const std::string &name, InsnVariable::Type typ,
             const IndentedHeaderBase &h) {
  auto &out(h.indent());
  switch ( typ ) {
  case InsnVariable::RegisterType:
    out << "std::shared_ptr<::nnc::compile::RtlVariable> ";
    break;

  case InsnVariable::RegTypeType:
    out << "std::shared_ptr<::nnc::compile::RtlType> ";
    break;

  case InsnVariable::ConstantType:
    out << "std::span<std::uint8_t> ";
    break;
  }
  out << "var_" << cName(name) << ";" << std::endl;
}

std::string ArchDescBuilder::cArchName() const {
  if ( m_name ) return cName(*m_name);
   else return "";
}

void ArchDescBuilder::includeCHeaders(std::ostream &out) const {
  for ( const auto &h: m_cheaders ) {
    out << h;
  }
}

std::string cName(const std::string &orig, bool full) {
  std::string ret(orig);
  for ( auto &c : ret ) {
    if ( !isalpha(c) && !isdigit(c) && c != '_' )
      c = '_';
  }
  if ( full && (ret == "and" || ret == "and_eq" ||
                ret == "bitand" || ret == "bitor" ||
                ret == "compl" || ret == "not" ||
                ret == "not_eq" || ret == "or" ||
                ret == "or_eq" || ret == "xor" ||
                ret == "xor_eq" || ret == "int" ||
                ret == "unsigned" || ret == "signed" ||
                ret == "long" || ret == "char" ||
                ret == "short" || ret == "float" ||
                ret == "double" || ret == "if" ||
                ret == "else" || ret == "default" ||
                ret == "auto" || ret == "throw" ||
                ret == "catch" || ret == "return" ||
                ret == "while" || ret == "for" ||
                ret == "do" || ret == "bool" ||
                ret == "void" || ret == "virtual" ||
                ret == "class" || ret == "struct" ||
                ret == "typedef" || ret == "switch" ||
                ret == "case" || ret == "continue" ||
                ret == "break" || ret == "true" ||
                ret == "false" || ret == "operator" ||
                ret == "goto" || ret == "const" ||
                ret == "try" || ret == "union" ||
                ret == "volatile" || ret == "nullptr" ||
                ret == "public" || ret == "private" ||
                ret == "protected" || ret == "delete" ||
                ret == "new" || ret == "decltype" ||
                ret == "sizeof" || ret == "typeid" ||
                ret == "this" || ret == "template" ||
                ret == "asm" || ret == "enum" ||
                ret == "const_cast" || ret == "static_cast" ||
                ret == "dynamic_cast" || ret == "constexpr" ||
                ret == "explicit" || ret == "extern" ||
                ret == "friend" || ret == "inline" ||
                ret == "register" || ret == "reinterpret_cast" ||
                ret == "static" || ret == "static_assert" ||
                ret == "using" ) ) {
    ret.insert(0, "c_");
  }
  return ret;
}

std::string cInsnName(const std::string &orig) {
  std::stringstream s;
  s << "insn::" << cName(orig);
  return s.str();
}
